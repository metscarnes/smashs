<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> SMASHS - Ta Rencontre Charnelle</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/metscarnes/bimi-metscarnes/main/Logo%20Mets%20Carn%C3%A9s%20HD.png">
    <link href="https://db.onlinewebfonts.com/c/194ce65461099b38279d03e32740d78e?family=Loyola+Pro+Bold" rel="stylesheet" type="text/css"/>
    <link href="https://fonts.googleapis.com/css2?family=Playpen+Sans:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <!-- ========================================================== -->
    <!-- ============== BLOC 1 : STYLES CSS COMPLET ============== -->
    <!-- ========================================================== -->
    <style>
        :root { --primary: #edc196; --accent: #cc8956; --dark: #040508; --dark-secondary: #50241c; --text-light: #edc196; --text-secondary: rgba(237, 193, 150, 0.7); --border-subtle: rgba(204, 137, 86, 0.2); --glow: rgba(237, 193, 150, 0.4); --transition-speed-fast: 0.4s; --transition-speed-medium: 0.6s; --transition-speed-slow: 1s; --transition-easing: cubic-bezier(0.25, 1, 0.5, 1); }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; overflow: hidden; background: var(--dark); }
        body { font-family: 'Playpen Sans', sans-serif; color: var(--text-light); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        body::before { content: ''; position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.03'/%3E%3C/svg%3E"); pointer-events: none; z-index: -1; opacity: 0.6; }
        h1, h2, h3, h4, .btn { font-family: 'Loyola Pro Bold', serif; color: var(--primary); }
        .view-container { position: fixed; inset: 0; opacity: 0; pointer-events: none; transform: scale(1.05); transition: opacity var(--transition-speed-medium) ease, transform var(--transition-speed-medium) ease; display: flex; justify-content: center; align-items: center; padding: 1rem; overflow-y: auto; }
        .view-container.is-visible { opacity: 1; pointer-events: auto; transform: scale(1); }
        .btn { background: var(--accent); color: var(--dark); border: none; padding: 1.2rem 3rem; font-size: 1.1rem; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 8px 30px rgba(204, 137, 86, 0.3); letter-spacing: 1px; text-transform: uppercase; }
        .btn:hover { background: var(--primary); transform: translateY(-3px); box-shadow: 0 12px 40px rgba(237, 193, 150, 0.4); }
        #welcome-screen { background: linear-gradient(135deg, var(--dark) 0%, #0a0a0c 50%, var(--dark-secondary) 100%); z-index: 100; }
        .welcome-content { text-align: center; max-width: 900px; animation: slideUp 1.4s cubic-bezier(0.16, 1, 0.3, 1) 0.3s backwards; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(80px); } to { opacity: 1; transform: translateY(0); } }
        .welcome-logo { margin-bottom: 3rem; filter: drop-shadow(0 20px 60px rgba(237, 193, 150, 0.5)); animation: float 5s ease-in-out infinite; }
        .welcome-logo img { width: 120px; height: auto; }
        @keyframes float { 0%, 100% { transform: translateY(0) rotate(-3deg) scale(1); } 50% { transform: translateY(-30px) rotate(3deg) scale(1.05); } }
        .welcome-title { font-size: clamp(2.5rem, 8vw, 5.5rem); margin-bottom: 2rem; letter-spacing: 3px; text-transform: uppercase; text-shadow: 0 5px 30px rgba(237, 193, 150, 0.4); line-height: 1.1; }
        .welcome-title::after { content: ''; display: block; width: 120px; height: 3px; background: linear-gradient(90deg, transparent, var(--accent), transparent); margin: 1.5rem auto 0; animation: lineGrow 1.5s ease-out 0.8s backwards; }
        @keyframes lineGrow { from { width: 0; opacity: 0; } to { width: 120px; opacity: 1; } }
        .welcome-description { color: var(--text-secondary); font-size: 1.2rem; line-height: 2; margin-bottom: 3rem; font-weight: 300; font-style: italic; }
        .btn-welcome { padding: 1.6rem 3.5rem; font-size: 1.1rem; border: none; cursor: pointer; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); letter-spacing: 1.5px; text-transform: uppercase; background: var(--accent); color: var(--dark); box-shadow: 0 10px 40px rgba(204, 137, 86, 0.4); position: relative; overflow: hidden; }
        .btn-welcome::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent); transition: left 0.6s; }
        .btn-welcome:hover::before { left: 100%; }
        .btn-welcome:hover { background: var(--primary); transform: translateY(-4px); box-shadow: 0 15px 50px rgba(237, 193, 150, 0.6); }
        #app { z-index: 50; }
        .container { width: 100%; max-width: 1200px; margin: auto; background: linear-gradient(135deg, var(--dark-secondary) 0%, rgba(4, 5, 8, 0.95) 100%); box-shadow: 0 40px 120px rgba(0, 0, 0, 0.8), 0 0 1px 1px var(--border-subtle); padding: 2rem 4rem; border: 1px solid var(--border-subtle); position: relative; opacity: 0; transform: translateY(20px); transition: opacity var(--transition-speed-medium) var(--transition-easing), transform var(--transition-speed-medium) var(--transition-easing); }
        #app.is-visible .container { opacity: 1; transform: translateY(0); }
        .container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, var(--accent), transparent); opacity: 0.5; }
.header {
    display: flex;
    justify-content: center; /* ✅ Centre le titre horizontalement */
    align-items: center;
    margin-bottom: 3rem;
    position: relative; /* ✅ Contexte de positionnement pour les boutons */
}

        .header .header-actions {
    position: absolute; /* ✅ Sort les boutons du flux normal */
    top: 50%; /* ✅ Aligne verticalement */
    transform: translateY(-50%); /* ✅ Ajustement fin de l'alignement vertical */
    width: 100%; /* ✅ Fait en sorte que le conteneur prenne toute la largeur */
    display: flex; /* ✅ Utilise flex pour positionner les boutons à l'intérieur */
    justify-content: space-between; /* ✅ Pousse les boutons aux extrémités */
    pointer-events: none; /* ✅ Empêche le conteneur de bloquer les clics sur le titre */
}
.header .header-actions .btn-icon {
    pointer-events: auto; /* ✅ Réactive les clics sur les boutons eux-mêmes */
}
.header .main-title-wrapper {
    text-align: center;
    display: flex; /* ✅ Active le mode flex */
    flex-direction: column; /* ✅ Aligne les enfants verticalement */
    align-items: center; /* ✅ Centre les enfants horizontalement */
    gap: 0.5rem; /* ✅ Ajoute un petit espace entre le sous-titre et le bouton */
}
        .btn-icon { background: rgba(237, 193, 150, 0.05); border: 1px solid var(--border-subtle); width: 44px; height: 44px; font-size: 1.2rem; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; color: var(--text-secondary); }
        .btn-icon:hover { border-color: var(--accent); background: rgba(204, 137, 86, 0.15); transform: translateY(-2px); color: var(--primary); }
        .main-title { font-size: clamp(2rem, 5vw, 2.8rem); margin: 0; letter-spacing: 2px; text-transform: uppercase; text-shadow: 0 4px 20px rgba(237, 193, 150, 0.3); }
        .subtitle { font-size: 1.1rem; color: var(--text-secondary); font-weight: 300; font-style: italic; }
        .screen { display: none; min-height: 60vh; }
        .screen.active { display: block; animation: content-entry 0.6s var(--transition-easing) forwards; }
        .screen.is-exiting { opacity: 0; transform: translateY(-20px); pointer-events: none; transition: opacity 0.4s ease-out, transform 0.4s ease-out; }
        @keyframes content-entry { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        #intro-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; gap: 2rem; }
        #dialogue { font-size: 1.6rem; line-height: 1.8; max-width: 700px; transition: opacity 0.8s ease; }
        .inputs, .buttons { display: flex; gap: 1.5rem; align-items: center; }
        .inputs { flex-direction: column; opacity: 0; transition: opacity 0.8s ease; }
        .btn-genre { font-family: 'Playpen Sans', sans-serif; font-size: 1.1rem; padding: 1rem 2.2rem; border: 1px solid var(--border-subtle); background: transparent; color: var(--text-light); cursor: pointer; transition: all 0.3s ease; }
        .btn-genre:hover, .btn-genre.selected { border-color: var(--accent); background: rgba(204, 137, 86, 0.2); transform: translateY(-2px); }
        input[type="text"] { background: rgba(80, 36, 28, 0.3); border: 1px solid var(--border-subtle); color: var(--text-light); padding: 1rem 1.5rem; font-size: 1.1rem; width: 100%; max-width: 350px; text-align: center; font-family: 'Playpen Sans', sans-serif; transition: all 0.3s ease; }
        input[type="text"]:focus { outline: none; border-color: var(--accent); background: rgba(80, 36, 28, 0.5); box-shadow: 0 0 0 3px rgba(204, 137, 86, 0.15); }
        #question-flow.active { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; flex-grow: 1; }
        #q-progress { font-size: 0.85rem; color: var(--text-secondary); font-weight: 700; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 2rem; }
        #q-text { font-size: clamp(1.8rem, 5vw, 2.6rem); margin: 1rem 0 0.5rem; line-height: 1.3; }
        .question-helper { color: var(--text-secondary); font-size: 1.05rem; margin-bottom: 2.5rem; font-weight: 300; font-style: italic; }
        .answers { display: grid; gap: 1.2rem; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); width: 100%; }
        .answer-card { background: rgba(80, 36, 28, 0.3); border: 1px solid var(--border-subtle); padding: 1.6rem; cursor: pointer; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); user-select: none; position: relative; overflow: hidden; text-align: center; }
        .answer-card:hover { transform: translateY(-5px); border-color: var(--accent); box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6); background: rgba(237, 193, 150, 0.05); }
        .answer-card.selected { border-color: var(--accent); background: rgba(204, 137, 86, 0.2); transform: translateY(-5px); box-shadow: 0 10px 40px rgba(204, 137, 86, 0.3); }
        .answer-card .icon { font-size: 3.5rem; display: block; filter: drop-shadow(0 4px 10px rgba(237, 193, 150, 0.2)); margin-bottom: 1rem; }
        .answer-card .text { font-weight: 600; font-size: 1.1rem; line-height: 1.6; color: var(--text-light); }
        .answer-card.small-text .text { font-size: 0.95rem; }
        .answer-card.selected::after { content: '✓'; position: absolute; top: -12px; right: -12px; width: 34px; height: 34px; background: var(--accent); color: var(--dark); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.1rem; box-shadow: 0 6px 20px rgba(204, 137, 86, 0.6); border: 2px solid var(--dark); animation: checkmarkPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
        @keyframes checkmarkPop { 0% { transform: scale(0) rotate(-180deg); } 50% { transform: scale(1.2) rotate(10deg); } 100% { transform: scale(1) rotate(0deg); } }
        #swipe-screen.active { display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 1rem; }
.card-deck {
  position: relative;
  width: 100%;
  max-width: 450px;
  height: 500px;
  max-height: 55vh;
  margin-bottom: 0.5rem; /* ✅ Marge inférieure réduite pour remonter les boutons d'action */
  overflow: visible; /* Allow expanded cards to overflow the deck container */
}

.card {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #1a1614;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border-subtle);
  opacity: 0;
  transform: scale(0.95);
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  pointer-events: none;
  user-select: none;
  border-radius: 20px;
  overflow: visible; /* allow info area to grow outside when expanded */
  touch-action: pan-y;
  will-change: transform;
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
        .card:hover { transform: scale(1.02); box-shadow: 0 15px 50px rgba(0,0,0,0.5); }
        .card.is-next { opacity: 0.5; transform: scale(0.95); }
        .card.is-active { opacity: 1; transform: scale(1); cursor: grab; pointer-events: auto; z-index: 10; }
        .card-choice { position: absolute; top: 50%; transform: translateY(-50%); opacity: 0; transition: opacity 0.3s ease; z-index: 10; filter: drop-shadow(0 4px 12px rgba(0,0,0,0.5)); font-size: 3rem; font-weight: bold; text-transform: uppercase; letter-spacing: 4px; padding: 0.5rem 1rem; border: 5px solid; }
        .card-choice.like { left: 30px; color: #4caf50; border-color: #4caf50; transform: translateY(-50%) rotate(-15deg); }
        .card-choice.nope { right: 30px; color: #f44336; border-color: #f44336; transform: translateY(-50%) rotate(15deg); }
        .card-gradient-overlay { position: absolute; bottom: 0; left: 0; right: 0; height: 60%; background: linear-gradient(to top, rgba(26, 22, 20, 0.95) 0%, rgba(26, 22, 20, 0.7) 40%, transparent 100%); pointer-events: none; }
        .card-sensor-bars { position: absolute; top: 0; left: 0; right: 0; display: grid !important; grid-template-columns: repeat(4, 1fr); align-items: center; justify-items: center; gap: 10px; padding: 8px 15px; background: rgba(0, 0, 0, 0.45); border-bottom: 1px solid rgba(255,255,255,0.05); z-index: 5; height: 60px; }
        .thermo-line { display: flex; flex-direction: column; align-items: center; justify-content: flex-end; width: 100%; opacity: 0; animation: fadeInThermo 0.5s ease forwards; animation-delay: var(--delay, 0s); }
        .thermo-bar-row { display: flex; align-items: center; justify-content: center; gap: 6px; width: 90%; }
        .thermo-icon { font-size: 1rem; flex-shrink: 0; }
        .thermo-bar-container { flex: 1; height: 6px; background: rgba(255,255,255,0.15); border-radius: 3px; overflow: hidden; position: relative; }
        .thermo-bar-fill { height: 100%; border-radius: 3px; width: 0%; transition: width 1.2s cubic-bezier(0.4, 0, 0.2, 1); animation: fillProgress 1.4s ease forwards; animation-delay: var(--delay, 0s); }
        .thermo-text { font-size: 0.75rem; font-weight: 500; color: rgba(237,193,150,0.9); text-shadow: 0 1px 2px rgba(0,0,0,0.4); margin-top: 3px; text-align: center; letter-spacing: 0.3px; }
        @keyframes fillProgress { from { width: 0%; } to { width: var(--target-width); } }
        @keyframes fadeInThermo { from { opacity: 0; transform: translateY(-6px); } to { opacity: 1; transform: translateY(0); } }
        .thermo-bar-fill { animation-name: fillProgress, pulseBar; animation-duration: 1.4s, 3s; animation-timing-function: ease, ease-in-out; animation-iteration-count: 1, infinite; animation-delay: var(--delay, 0s), calc(var(--delay, 0s) + 1s); }
        @keyframes pulseBar { 0%,100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }

/* ========================================================== */
/* ========= DÉBUT DU BLOC FINAL : .card-info et expansion ========= */
/* ========================================================== */

.card {
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* ✅ C'est LA clé : on anime la hauteur de la carte entière */
}
.card.is-expanded {
    height: 580px; /* ✅ On donne une grande hauteur à la carte une fois déployée */
}

.card-gradient-overlay {
    height: 50%;
    transition: height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.card.is-expanded .card-gradient-overlay {
    height: 75%; /* ✅ Le dégradé s'agrandit pour une meilleure lisibilité */
}

/* ✅ La solution : on ancre bien par le bas et on anime la HAUTEUR du bloc d'info */
.card-info {
  /* Make the info area part of the document flow so it can grow naturally */
  position: relative;
  padding: 20px;
  color: #f5f1e8;
  z-index: 6;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  max-height: 180px; /* compact by default */
  overflow: hidden; /* hide overflow when collapsed */
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  background: linear-gradient(180deg, rgba(26,22,20,0) 0%, rgba(26,22,20,0) 60%); /* neutral background so text is readable */
}
.card.is-expanded .card-info {
  max-height: 1000px; /* allow to expand to full content */
}

/* New media area: fixed height, background image lives here so the info can expand beneath */
.card-media {
  width: 100%;
  height: 320px; /* fixed visual image area */
  min-height: 220px;
  max-height: 420px;
  background-size: cover;
  background-position: center;
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  position: relative;
  overflow: hidden;
  flex-shrink: 0;
}
.card.is-expanded .card-media {
  /* keep the media height constant so it doesn't overlap the info on expand */
  height: 320px;
}

.card-info-content {
    cursor: pointer;
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
}

.card-text-wrapper {
    flex-grow: 1;
  min-width: 0; /* allow the text to shrink instead of forcing the card wider */
}

.card-name {
    font-size: 1.8rem;
    font-weight: 700;
    margin: 0;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    letter-spacing: -0.5px;
}

.card-location {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.95rem;
    color: rgba(245,241,232,0.85);
    margin-bottom: 12px;
}

/* ✅ On affiche bien une seule ligne par défaut */
.card-bio {
    margin: 12px 0 0;
    font-size: 0.95rem;
    line-height: 1.5;
    color: rgba(245,241,232,0.9);
    font-style: italic;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
  display: -webkit-box;
  line-clamp: 1;
  -webkit-line-clamp: 1; /* ✅ Une seule ligne visible, avec "..." automatique */
  -webkit-box-orient: vertical;
    overflow: hidden;
    transition: all 0.4s ease;
}

.card.is-expanded .card-bio {
  line-clamp: 20;
  -webkit-line-clamp: 20; /* ✅ On retire la limite pour tout afficher */
}

.card-expand-chevron {
    flex-shrink: 0;
    width: 28px;
    height: 28px;
    margin-top: 2px;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.card.is-expanded .card-expand-chevron {
    transform: rotate(180deg); /* ✅ La flèche tourne */
}

.card-details-arrow {
    display: none;
}

.card-external-link {
    display: inline-block;
    background: var(--accent);
    color: var(--dark);
    text-decoration: none;
    padding: 0.8rem 1.5rem;
    font-family: 'Loyola Pro Bold', serif;
    font-size: 0.9rem;
    text-align: center;
    border-radius: 4px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    transition: opacity 0.4s ease, transform 0.4s ease;
    opacity: 0;
    transform: translateY(10px);
    pointer-events: none;
}

.card-external-link:hover {
    background: var(--primary);
    transform: translateY(-2px) !important;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5);
}

.card.is-expanded .card-external-link {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

/* ========================================================== */
/* ========= FIN DU BLOC FINAL : .card-info et expansion ========= */
/* ========================================================== */
        .card-details-arrow { font-size: 2rem; cursor: pointer; color: white; background: rgba(255,255,255,0.2); width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease; flex-shrink: 0; }
        .card-details-arrow:hover { transform: scale(1.1); }
        .profile-radar-container { width: 150px; height: 150px; position: relative; }
        .profile-radar-label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary); }
        .actions { display: flex; gap: 1rem; justify-content: center; align-items: center; }
        .action-btn { background: #23272f; border: none; color: white; box-shadow: 0 5px 20px rgba(0,0,0,0.3); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.3s ease; }
        .action-btn:hover { transform: scale(1.1); }
        .action-btn.undo { color: #f9b930; font-size: 1.5rem; width: 60px; height: 60px; }
        .action-btn.dislike { color: #fe5269; font-size: 2.5rem; width: 70px; height: 70px; }
        .action-btn.like { color: #2de9a1; font-size: 2rem; width: 70px; height: 70px; }
        #results-screen h1, #profile-screen h1 { text-align: center; margin-bottom: 2rem; }
        #matches-list { max-width: 800px; margin: 0 auto; }
        .match-item { background: rgba(80, 36, 28, 0.3); border: 1px solid var(--border-subtle); padding: 2rem; margin-bottom: 1.5rem; transition: all 0.3s ease; }
        .match-item:hover { background: rgba(80, 36, 28, 0.5); transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .match-item h3 { font-size: 1.8rem; margin-bottom: 1rem; }
        .match-item p { color: var(--text-secondary); line-height: 1.7; margin-bottom: 1rem; }
        .match-item a { color: var(--accent); text-decoration: none; font-weight: 600; transition: color 0.3s; }
        .match-item a:hover { color: var(--primary); }
        .results-actions { display: flex; gap: 1rem; justify-content: center; margin-top: 3rem; flex-wrap: wrap; }
        #loading-screen { background: transparent; z-index: 200; }
        #loading-screen::before, #loading-screen::after { content: ''; position: absolute; top: 0; width: 50.5%; height: 100%; background: var(--dark-secondary); z-index: 2; transition: transform var(--transition-speed-slow) cubic-bezier(0.77, 0, 0.175, 1); box-shadow: 5px 0 30px rgba(0, 0, 0, 0.5); }
        #loading-screen::before { left: 0; }
        #loading-screen::after { right: 0; }
        #loading-screen.is-opening::before { transform: translateX(-100%); }
        #loading-screen.is-opening::after { transform: translateX(100%); }
        .loading-content { position: relative; z-index: 3; text-align: center; width: 100%; display: flex; justify-content: center; align-items: center; min-height: 200px; }
        .loading-phase-1, .loading-phase-2 { transition: opacity 0.5s ease-out, transform 0.5s ease-out; position: absolute; width: 90%; max-width: 400px; }
        #loading-screen .loading-phase-2 { opacity: 0; transform: translateY(20px); pointer-events: none; }
        #loading-screen.is-finished .loading-phase-1 { opacity: 0; transform: scale(0.95); pointer-events: none; }
        #loading-screen.is-finished .loading-phase-2 { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .loading-text { font-size: clamp(1.2rem, 4vw, 1.8rem); margin-bottom: 2rem; letter-spacing: 1px; text-transform: uppercase; text-shadow: 0 2px 15px var(--glow); animation: textFadeInOut 1.5s ease-in-out infinite; }
        @keyframes textFadeInOut { 0%, 100% { opacity: 0; transform: translateY(10px); } 15%, 85% { opacity: 1; transform: translateY(0); } }
        .loading-bar-container { width: 100%; max-width: 300px; height: 4px; background: rgba(237, 193, 150, 0.2); overflow: hidden; margin: 0 auto; }
        .loading-bar { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent) 0%, var(--primary) 100%); box-shadow: 0 0 20px var(--glow); }
        .reveal-button { font-size: 1.2rem; letter-spacing: 2px; text-transform: uppercase; color: var(--primary); background: transparent; border: 2px solid var(--accent); padding: 1.2rem 3rem; cursor: pointer; transition: all 0.4s ease; font-family: 'Loyola Pro Bold', serif; }
        .reveal-button:hover { color: var(--dark); background: var(--primary); border-color: var(--primary); box-shadow: 0 0 30px var(--glow); }
        .modal-overlay { position: fixed; inset: 0; background: rgba(4, 5, 8, 0.85); backdrop-filter: blur(8px); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity var(--transition-speed-fast) ease; }
        .modal-overlay.is-visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--dark-secondary); padding: 2.5rem; width: 90%; max-width: 500px; border: 1px solid var(--border-subtle); box-shadow: 0 30px 100px rgba(0, 0, 0, 0.8); transform: scale(0.95); transition: transform var(--transition-speed-fast) var(--transition-easing); max-height: 90vh; overflow-y: auto; position: relative; text-align: center; }
        .modal-overlay.is-visible .modal-content { transform: scale(1); }
        #alert-modal-title { font-size: 1.8rem; margin-bottom: 1rem; letter-spacing: 1px; text-transform: uppercase; }
        #alert-modal-text { font-size: 1.1rem; line-height: 1.8; margin-bottom: 2rem; color: var(--text-secondary); }
        .modal-btn { padding: 1rem 2.5rem; font-size: 1rem; border: none; cursor: pointer; transition: all 0.3s ease; letter-spacing: 1px; text-transform: uppercase; font-family: 'Loyola Pro Bold', serif; }
        .modal-btn-confirm { background: var(--accent); color: var(--dark); box-shadow: 0 6px 20px rgba(204, 137, 86, 0.4); }
        .modal-btn-confirm:hover { background: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 30px rgba(237, 193, 150, 0.5); }
        .modal-btn-secondary { background: transparent; border: 1px solid var(--border-subtle); color: var(--text-light); }
        .modal-btn-secondary:hover { background: rgba(237, 193, 150, 0.1); border-color: var(--accent); }
        #alert-modal-buttons { display: flex; gap: 1rem; justify-content: center; }
        #alert-modal-buttons .modal-btn { flex-grow: 1; }
        #product-modal-overlay .modal-content { background: linear-gradient(135deg, var(--dark) 0%, #1a1614 100%); border: 1px solid var(--border-subtle); border-radius: 0; padding: 2rem 2.5rem; max-width: 900px; font-family: 'Playpen Sans', sans-serif; color: var(--text-secondary); line-height: 1.7; }
        .product-title { font-size: 2.2rem; color: var(--primary); text-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); letter-spacing: 1px; position: relative; display: inline-block; margin-bottom: 1rem; }
        .product-title::after { content: ''; position: absolute; bottom: -8px; left: 0; width: 60px; height: 3px; background: linear-gradient(90deg, var(--accent), transparent); }
        .profile-header { display: flex; align-items: center; gap: 1.5rem; border-bottom: 1px solid var(--border-subtle); padding-bottom: 1.5rem; margin-bottom: 2rem; }
        .profile-image { width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 2px solid var(--border-subtle); box-shadow: 0 5px 20px rgba(0,0,0,0.4); flex-shrink: 0; }

    /* Profile screen: ensure content fits viewport and action buttons are visible on small screens */
    #profile-screen .profile-container {
      text-align: center;
      max-width: 700px;
      margin: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      min-height: calc(100vh - 140px); /* leave space for header / safe-area */
      padding: 1rem 0 1.5rem;
    }

    #profile-screen .profile-actions-group {
      margin-top: auto; /* push actions to the bottom of the container */
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
      width: 100%;
    }

    #profile-screen .profile-match-visual { width: 120px; height: 80px; }
    #profile-screen .recommendation-label { font-size: 1.1rem; }

    @media (max-width: 480px), (max-height: 640px) {
      #profile-screen .profile-container { min-height: calc(100vh - 100px); padding: 0.75rem 0; }
      #profile-screen .profile-match-visual { width: 96px; height: 64px; }
      #profile-screen .profile-reveal-item { margin-bottom: 0.5rem; }
      #profile-screen .recommendation-label { font-size: 1rem; }
      #profile-screen .profile-actions-group .btn, #profile-screen .profile-actions-group .btn-cta-profile { width: 92%; max-width: 360px; padding: 0.9rem 1rem; font-size: 1rem; }
    }
        .nutri-score-badge { border: 1px solid var(--border-subtle); padding: 1rem 1.2rem; text-align: center; min-width: 120px; background: rgba(0,0,0,0.2); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .nutri-score-badge .label { font-size: 0.7rem; color: var(--accent); font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem; }
        .nutri-score-badge .score { font-size: 2.5rem; font-weight: 700; line-height: 1; }
        .score-A { color: #8cc63f; } .score-B { color: #c4d82f; } .score-C { color: #f8b518; } .score-D { color: #eb842a; } .score-E { color: #e34033; }
        .card-section { background: rgba(0,0,0,0.2); padding: 1.5rem 2rem; border: 1px solid var(--border-subtle); margin-top: 2rem; }
        .section-title { margin: 0 0 1.5rem 0; font-size: 1rem; color: var(--primary); text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid var(--border-subtle); padding-bottom: 1rem; font-family: 'Loyola Pro Bold', serif; }
        .section-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; }
        .description-label { display: block; margin-bottom: 0.5rem; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: var(--accent); font-weight: 600; }
        .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; }
        .nutrient-card { background: rgba(0,0,0,0.2); padding: 1rem; border: 1px solid var(--border-subtle); text-align: center; }
        .nutrient-card .label { font-size: 0.65rem; color: var(--accent); font-weight: 600; letter-spacing: 1px; text-transform: uppercase; }
        .nutrient-card .value { font-size: 1.5rem; font-weight: 700; color: var(--primary); margin-top: 0.5rem; }
        
/* ========================================================== */
/* ========= DÉBUT DU BLOC MODIFIÉ : Feedback Toast Compact ========= */
/* ========================================================== */

.feedback-toast {
    position: relative;
    bottom: auto;
    left: auto;
    background: rgba(4, 5, 8, 0.9);
    backdrop-filter: blur(10px);
    color: var(--text-light);
    padding: 1rem 1.5rem;
    border-radius: 8px;
    border: 1px solid var(--border-subtle);
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    font-family: 'Playpen Sans', sans-serif;
    font-style: italic;
    font-size: 0.95rem;
    width: 100%;
    max-width: 450px;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease, transform 0.5s ease;
    z-index: 20;
    margin-bottom: 0.75rem; /* ✅ Marge inférieure réduite */
    transform: scale(0.95); /* ✅ On utilise le scale pour l'animation d'entrée, ce qui n'affecte pas l'espacement vertical */
}
.feedback-toast.is-visible {
    opacity: 1;
    transform: scale(1); /* ✅ Animation de retour à la taille normale */
    pointer-events: auto;
}

/* ========================================================== */
/* ========= FIN DU BLOC MODIFIÉ : Feedback Toast Compact ========= */
/* ========================================================== */

/* ========================================================== */
/* ======= BLOCS CSS POUR L'EXPANSION DES CARTES =========== */
/* ========================================================== */

/* Ensure expanded card fills available viewport area so internal content is readable */
.card.is-expanded {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  top: 72px; /* keep header visible */
  width: calc(100% - 2rem);
  max-width: 760px;
  height: calc(100vh - 96px);
  max-height: calc(100vh - 96px);
  z-index: 6000;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 30px 90px rgba(0,0,0,0.75);
}

/* media stays at top of expanded card; keep fixed area so info scrolls underneath */
.card.is-expanded .card-media {
  height: 40vh;
  min-height: 160px;
  max-height: 48vh;
  background-size: cover;
  background-position: center;
}

/* Info becomes scrollable within the expanded card */
.card.is-expanded .card-info {
  position: relative;
  overflow-y: auto;
  max-height: calc(100% - 40vh);
  /* leave extra bottom padding so a fixed CTA can sit above the edge */
  padding: 1.25rem 1.25rem 5.5rem;
}

/* Pin CTA inside expanded card so it never overlaps content and stays visible */
.card.is-expanded .card-external-link {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: 18px;
  opacity: 1;
  pointer-events: auto;
  z-index: 12;
  /* ensure the animated entrance still works */
  transition: opacity 0.3s ease, transform 0.3s ease;
}

/* Collapsed: show a compact info preview (name + chevron) */
.card .card-info {
  max-height: 92px;
  overflow: hidden;
  transition: max-height 0.36s ease, padding 0.3s ease;
}
.card .card-info .card-name {
  font-size: 1.6rem;
  font-weight: 700;
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  min-width: 0; /* prevent long words from forcing parent width */
}

/* When the card is expanded, allow the product name to wrap on multiple lines */
.card.is-expanded .card-info .card-name {
  white-space: normal;
  overflow: visible;
  text-overflow: unset;
}

/* Chevron pulse to hint at more content when collapsed */
@keyframes chev-pulse { 0% { transform: translateY(0); opacity: 0.9; } 50% { transform: translateY(-4px); opacity: 1; } 100% { transform: translateY(0); opacity: 0.9; } }
.card:not(.is-expanded) .card-expand-chevron { animation: chev-pulse 1.1s ease-in-out infinite; stroke: #ff3b3b; color: #ff3b3b; }

@media (max-height: 640px) {
  .card.is-expanded { top: 56px; height: calc(100vh - 72px); }
  .card.is-expanded .card-media { min-height: 140px; }
  .card .card-info { max-height: 84px; }
}

/* ========================================================== */
/* ======= FIN BLOCS CSS POUR L'EXPANSION DES CARTES ========= */
/* ========================================================== */



/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Jauge de Convergence ========= */
/* ========================================================== */

.convergence-gauge-container {
    width: 100%;
    max-width: 300px;
    margin: 0 auto 0.75rem; /* ✅ Marge inférieure réduite de moitié */
    text-align: center;
}
.convergence-gauge-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}
.convergence-gauge-bar {
    width: 100%;
    height: 8px;
    background: rgba(80, 36, 28, 0.5); /* ✅ Fond de la jauge */
    border: 1px solid var(--border-subtle);
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}
.convergence-gauge-fill {
    height: 100%;
    width: 0%; /* ✅ Commence à 0% */
    background: linear-gradient(90deg, var(--accent) 0%, var(--primary) 100%);
    box-shadow: 0 0 15px var(--glow);
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1); /* ✅ Animation fluide */
    border-radius: 4px;
}
.convergence-gauge-percent {
    font-size: 1rem;
    font-weight: 700;
    color: var(--primary);
    margin-top: 0.5rem;
    font-family: 'Loyola Pro Bold', serif;
}

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Icône d'Aide ========= */
/* ========================================================== */

.help-icon {
    display: inline-block;
    width: 18px;
    height: 18px;
    background: var(--border-subtle);
    color: var(--text-secondary);
    border-radius: 50%;
    font-size: 13px;
    font-weight: bold;
    text-align: center;
    line-height: 18px;
    cursor: pointer;
    margin-left: 8px;
    transition: all 0.3s ease;
    user-select: none;
    font-family: serif; /* Pour un '?' plus joli */
    vertical-align: middle; /* Pour bien l'aligner avec le texte */
}
.help-icon:hover {
    background: var(--accent);
    color: var(--dark);
    transform: scale(1.1) rotate(15deg);
}

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Coach Pop-up et Animation ========= */
/* ========================================================== */

/* On s'assure que le conteneur du label peut positionner le pop-up */
.convergence-gauge-label {
    position: relative; /* ✅ Contexte de positionnement pour le pop-up */
    display: inline-block; /* ✅ S'assure que le conteneur ne prend pas toute la largeur */
}

/* Le pop-up lui-même, caché par défaut */
#coach-popup {
    position: absolute;
    /* ✅ La nouvelle position par défaut, au-dessus du label */
    top: -10px;
    left: 50%;
    right: auto;
    transform: translateX(-50%) translateY(-100%);
    background: #e34033;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.8rem;
    font-family: 'Playpen Sans', sans-serif;
    white-space: nowrap;
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* La petite flèche du pop-up */
#coach-popup::after {
    content: '';
    position: absolute;
    /* ✅ On réoriente la flèche pour qu'elle pointe vers le BAS */
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: #e34033 transparent transparent transparent;
}

/* L'animation de pulsation */
@keyframes pulse-red {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(227, 64, 51, 0.7); }
    70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(227, 64, 51, 0); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(227, 64, 51, 0); }
}

/* La classe qui déclenche tout ! */
.convergence-gauge-label.has-hint .help-icon {
    background: #e34033; /* ✅ Devient rouge */
    color: white;
    animation: pulse-red 2s infinite; /* ✅ Lance l'animation de pulsation */
    border-color: #e34033;
}

/* Affiche le pop-up quand la classe est présente */
.convergence-gauge-label.has-hint #coach-popup {
    opacity: 1;
    /* ✅ On s'assure que l'animation de slide-in vient du haut */
    transform: translateX(-50%) translateY(-100%) translateY(-5px);
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Coach Pop-up et Animation ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Responsive Coach Pop-up ========= */
/* ========================================================== */

@media (max-width: 500px) {
    /* Sur mobile, on donne un peu d'espace au-dessus pour que le pop-up ne soit pas collé au header */
    .convergence-gauge-container {
        margin-top: 1.5rem; /* ✅ */
    }
@media (max-width: 500px) {
  /* Sur mobile, on donne un peu d'espace au-dessus pour que le pop-up ne soit pas collé au header */
  .convergence-gauge-container {
    margin-top: 1.5rem; /* ✅ */
  }

  #coach-popup {
    /* On change complètement le positionnement pour le mettre AU-DESSUS */
    top: -10px; /* ✅ Remonte le pop-up */
    left: 50%; /* ✅ Centre horizontalement par rapport au parent */
    right: auto; /* ✅ On annule la position à droite */
    transform: translateX(-50%) translateY(-100%); /* ✅ Centrage horizontal parfait et le place au-dessus */
    font-size: 0.75rem; /* On le rend un peu plus petit sur mobile */
  }

  #coach-popup::after {
    /* On réoriente la flèche pour qu'elle pointe vers le BAS */
    top: 100%; /* ✅ Se place en bas du pop-up */
    left: 50%; /* ✅ Se centre horizontalement */
    margin-top: 0;
    margin-left: -5px;
    /* La magie est ici : on change la bordure qui a la couleur */
    border-color: #e34033 transparent transparent transparent; /* ✅ */
  }

  /* On s'assure que l'animation de slide-in vient du haut */
  .convergence-gauge-label.has-hint #coach-popup {
    transform: translateX(-50%) translateY(-100%) translateY(-5px); /* ✅ Position de départ */
  }
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Responsive Coach Pop-up ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Style de l'Écran de Match ========= */
/* ========================================================== */

#match-screen-overlay {
    /* ✅ On force le fond dégradé pour écraser le fond noir transparent de .modal-overlay */
    background: linear-gradient(160deg, var(--dark-secondary) 0%, var(--accent) 150%);
    /* ✅ On annule explicitement l'effet de flou hérité de .modal-overlay */
    backdrop-filter: none;
    z-index: 5000; /* Doit être au-dessus de tout */
}
.match-content-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    width: 100%;
    height: 100%;
    overflow: hidden; /* Empêche les pulsations de déborder */
}

/* --- Animation de fond pulsante --- */
.pulse-bg {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(237, 193, 150, 0.2) 0%, rgba(237, 193, 150, 0) 70%);
    animation: pulse 4s ease-out infinite;
}
.pulse-1 { width: 300px; height: 300px; }
.pulse-2 { width: 500px; height: 500px; animation-delay: 1s; }
.pulse-3 { width: 700px; height: 700px; animation-delay: 2s; }

@keyframes pulse {
    0% { transform: scale(0.5); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: scale(1.2); opacity: 0; }
}

/* --- Photos de profil --- */
.match-pfps {
    display: flex;
    position: relative;
    margin-bottom: 2rem;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,0.5));
}

.match-pfp {
    width: 140px;
    height: 140px;
    border-radius: 50%;
    border: 5px solid var(--primary);
    background-color: var(--dark);
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 40px var(--glow);
    /* Animation d'entrée */
    opacity: 0;
    transform: scale(0.5);
}

#user-match-pfp {
    transform: translateX(20px) scale(0.5);
}
#meat-match-pfp {
    transform: translateX(-20px) scale(0.5);
    margin-left: -40px; /* Chevauchement des cercles */
}

/* --- Textes --- */
.match-title {
    font-size: clamp(4rem, 15vw, 7rem);
    text-transform: uppercase;
    letter-spacing: 5px;
    color: white;
    text-shadow: 0 5px 40px rgba(0,0,0,0.6);
    margin: 0;
    line-height: 1;
    /* Animation d'entrée */
    opacity: 0;
    transform: translateY(20px);
}

.match-subtitle {
    font-family: 'Playpen Sans', sans-serif;
    font-size: 1.2rem;
    color: rgba(255, 255, 255, 0.8);
    font-style: italic;
    margin-top: 1.5rem;
    /* Animation d'entrée */
    opacity: 0;
    transform: translateY(20px);
}


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-= DÉBUT DES BLOCS CSS À MODIFIER/AJOUTER =-=-=-=-=-= */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* --- 1. MODIFIEZ la classe .recommendation-label --- */
.recommendation-label {
    font-family: 'Loyola Pro Bold', serif;
    font-size: 1.8rem;
    color: var(--primary);
    text-transform: none;
    letter-spacing: 0;
    margin-bottom: 1.5rem;
    line-height: 1.3;
}

/* --- 2. SUPPRIMEZ l'ancienne classe .profile-cta-link --- */
/* (Supprimez complètement les règles pour .profile-cta-link et .profile-cta-link:hover) */

/* --- On garde le bouton principal CTA tel quel --- */
.btn-cta-profile {
    background: var(--accent);
    color: var(--dark);
    border: none;
    padding: 1.2rem 3rem;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 30px rgba(204, 137, 86, 0.3);
    letter-spacing: 1px;
    text-transform: uppercase;
    font-family: 'Loyola Pro Bold', serif;
    display: inline-block;
    text-decoration: none;
    margin-bottom: 1.5rem;
    animation: pulse-cta 2.5s infinite; /* ✅ C'est cette ligne qui active la pulsation. */
}
.btn-cta-profile:hover {
    background: var(--primary);
    transform: translateY(-3px);
    box-shadow: 0 12px 40px rgba(237, 193, 150, 0.4);
    animation-play-state: paused;
}


/* --- RÈGLE POUR LE BOUTON "CONTINUER" --- */
#continue-swiping-btn {
    /* Style copié du bouton principal */
    background: var(--accent);
    color: var(--dark);
    border: none;
    padding: 1rem 2.5rem;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 6px 20px rgba(204, 137, 86, 0.2);
    letter-spacing: 1px;
    text-transform: uppercase;
    font-family: 'Loyola Pro Bold', serif;
    
    /* Modifications spécifiques */
    margin-top: 1rem;
    /* Pas de propriété "animation" pour que ce bouton reste statique */ /* ✅ */
}
#continue-swiping-btn:hover {
    background: var(--primary);
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(237, 193, 150, 0.3);
}
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-=- FIN DES BLOCS CSS À MODIFIER/AJOUTER =-=-=-=-=-=- */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

.btn-cta-profile:hover {
    background: var(--primary);
    transform: translateY(-3px);
    box-shadow: 0 12px 40px rgba(237, 193, 150, 0.4);
    animation-play-state: paused; /* ✅ Arrête la pulsation au survol */
}

@keyframes pulse-cta {
    0% { transform: scale(1); box-shadow: 0 8px 30px rgba(204, 137, 86, 0.3); }
    50% { transform: scale(1.05); box-shadow: 0 12px 45px rgba(204, 137, 86, 0.5); }
    100% { transform: scale(1); box-shadow: 0 8px 30px rgba(204, 137, 86, 0.3); }
}


/* --- 4. MODIFIEZ .radar-legend pour le texte --- */
.radar-legend {
    position: absolute;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.7rem; /* Taille du texte */
    text-transform: uppercase;
    letter-spacing: 1px;
    pointer-events: none; /* Empêche d'interférer avec les clics */
}
.radar-legend .emoji {
    font-size: 1.5rem; /* Taille de l'emoji */
    display: block;
    margin-bottom: 2px;
}

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-=- FIN DES BLOCS CSS À MODIFIER/AJOUTER =-=-=-=-=-=- */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* ========================================================== */
/* ========= DÉBUT DU BLOC FINAL : CSS RESPONSIVE COMPLET ========= */
/* ========================================================== */

        @media (max-width: 768px) {
            /* === MICRO-OPTIMISATIONS === */
            .main-title {
                font-size: clamp(1.8rem, 5vw, 2.2rem);
            }
        }
            .action-btn.undo { 
                width: 44px; height: 44px; font-size: 1.1rem;
            }
            .action-btn.dislike, .action-btn.like { 
                width: 54px; height: 54px;
            }
            .action-btn.dislike { font-size: 2rem; }
            .action-btn.like { font-size: 1.8rem; }

            /* === COMPRESSION DES ESPACES === */
            .container { padding: 1.5rem; }
            .header { margin-bottom: 1.5rem; flex-direction: column; gap: 0.5rem; }
            .convergence-gauge-container { margin: 0 auto 0.75rem; }
            .actions { gap: 1rem; margin-top: 0.5rem; }

            /* === CONTRÔLE DE LA HAUTEUR DE LA CARTE === */
            #swipe-screen.active {
                height: 100%;
            }
            .card-deck {
                flex-grow: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 300px;
                max-height: 50vh;
            }
            .card {
                height: 100%;
                max-height: 480px;
                aspect-ratio: 10 / 14;
            }

            /* === AUTRES AJUSTEMENTS MOBILES === */
            .welcome-title { font-size: 2.5rem; }
            .welcome-description { font-size: 1rem; }
            .btn-welcome { padding: 1.2rem 2rem; font-size: 1rem; }
            .profile-header { flex-direction: column; text-align: center; }
        }

        @media (max-width: 640px) { 
            .card-sensor-bars { 
                grid-template-columns: repeat(2, 1fr); 
                gap: 10px 16px; 
                height: auto; 
                padding: 10px 12px; 
            } 
            .thermo-bar-row { 
                width: 95%; 
            } 
        }

/* ========================================================== */
/* ========= FIN DU BLOC FINAL : CSS RESPONSIVE COMPLET ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Style du Bouton Match ========= */
/* ========================================================== */

.btn-match-profile {
    margin-top: 3rem;
    padding: 1.2rem 2.5rem;
    background: var(--primary);
    color: var(--dark-secondary);
    border: none;
    font-size: 1.1rem;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    transition: all 0.3s ease;

    /* Animation d'entrée */
    opacity: 0;
    transform: translateY(20px);
}
.btn-match-profile:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Style du Bouton Match ========= */
/* ========================================================== */
/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Style du Bouton "Continuer" ========= */
/* ========================================================== */

#continue-swiping-btn-match {
    margin-top: 1rem;
    background: transparent;
    border: 1px solid var(--border-subtle);
    color: var(--text-light);
    font-size: 1rem;
    padding: 1rem 2.5rem;
    box-shadow: none;
}
#continue-swiping-btn-match:hover {
    background: rgba(237, 193, 150, 0.1);
    border-color: var(--accent);
    transform: translateY(-2px);
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Style du Bouton "Continuer" ========= */
/* ========================================================== */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-= DÉBUT BLOC WOW : ANIMATIONS ÉCRAN PROFIL =-=-=-=-= */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* --- Animation générale pour les éléments de texte --- */
@keyframes reveal-up {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* --- Classe utilitaire pour les éléments qui apparaissent --- */
.profile-reveal-item {
    opacity: 0; /* Commence caché */
    animation: reveal-up 0.8s cubic-bezier(0.25, 1, 0.5, 1) forwards;
}

/* --- Animation spécifique pour le graphique radar --- */
#profile-radar-final .radar-bg {
    opacity: 0;
    animation: reveal-up 0.5s ease-out 0.8s forwards; /* Le fond apparaît en premier */
}

#profile-radar-final .radar-shape {
    transform-origin: center;
    transform: scale(0); /* Le polygone commence tout petit au centre */
    animation: grow-shape 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) 1.2s forwards; /* Il grandit avec un effet "ressort" */
}

@keyframes grow-shape {
    from { transform: scale(0); }
    to { transform: scale(1); }
}

/* --- Animation de pulsation pour le graphique une fois dessiné --- */
#profile-radar-final .radar-shape {
    /* On ajoute une deuxième animation pour le faire pulser après coup */
    animation: grow-shape 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) 1.2s forwards, 
               pulse-glow 3s ease-in-out 2.5s infinite; /* ✅ */
}

@keyframes pulse-glow {
    0%, 100% {
        filter: drop-shadow(0 0 5px var(--glow));
    }
    50% {
        filter: drop-shadow(0 0 15px var(--primary));
    }
}

/* --- Animation pour les légendes du radar --- */
.radar-legend {
    opacity: 0;
    animation: reveal-up 0.6s ease-out 1.5s forwards; /* Apparaissent après le dessin du graphique */
}


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-=- FIN BLOC WOW : ANIMATIONS ÉCRAN PROFIL =-=-=-=-=- */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-=- DÉBUT BLOC CORRECTION : LÉGENDES RADAR =-=-=-=-= */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* On retire l'ancienne transformation générique */
.radar-legend {
    transform: none !important; /* ✅ Annule les anciens calculs pour laisser place aux nouvelles règles */
}

/* Nouvelles règles de positionnement spécifiques pour chaque coin */
.legend-top {
    top: -15%;
    left: 42%;
    transform: translate(-50%, calc(-100% - 5px)); /* ✅ Aligne par le bas et ajoute 5px de marge */
}

.legend-right {
    top: 30%;
    left: 90%;
    transform: translate(12px, -50%); /* ✅ Aligne par la gauche et ajoute 12px de marge */
}

.legend-bottom {
    bottom: -9%;
    left: 35%;
    transform: translate(-50%, calc(100% + 5px)); /* ✅ Aligne par le haut et ajoute 5px de marge */
}

.legend-left {
    top: 30%;
    left: -18%;
    transform: translate(calc(-100% - 12px), -50%); /* ✅ Aligne par la droite et ajoute 12px de marge */
}

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* =-=-=-=-=-=-=- FIN BLOC CORRECTION : LÉGENDES RADAR =-=-=-=-=- */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Galerie des Matchs ========= */
/* ========================================================== */

#results-screen {
    text-align: center;
    display: flex;
    flex-direction: column;
}

#results-screen h1 {
    margin-bottom: 0.5rem;
}

#results-screen .results-subtitle {
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 3rem;
}

#matches-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-width: 700px;
    width: 100%;
    align-self: center; /* Pour centrer la liste */
}

.match-gallery-item {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    background: rgba(80, 36, 28, 0.2);
    border: 1px solid var(--border-subtle);
    padding: 1rem 1.5rem;
    margin-bottom: 1.5rem;
    text-align: left;
    opacity: 0; /* Pour l'animation d'entrée */
    transform: translateX(-30px); /* Pour l'animation d'entrée */
    animation: slideInFromLeft 0.6s cubic-bezier(0.25, 1, 0.5, 1) forwards;
    animation-delay: var(--delay, 0s);
}

@keyframes slideInFromLeft {
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.match-gallery-pfps {
    position: relative;
    width: 120px;
    height: 80px;
    flex-shrink: 0;
}

.match-gallery-pfps .user-pfp,
.match-gallery-pfps .product-pfp {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid var(--primary);
    background-size: cover;
    background-position: center;
    box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    position: absolute;
    top: 0;
}

.match-gallery-pfps .user-pfp {
    left: 0;
    z-index: 2; /* Passe au-dessus de l'autre */
}

.match-gallery-pfps .product-pfp {
    left: 40px; /* Décale pour créer le chevauchement */
}

.match-gallery-info {
    flex-grow: 1;
}

.match-gallery-info h3 {
    font-family: 'Loyola Pro Bold', serif;
    font-size: 1.6rem;
    margin: 0 0 0.5rem;
    color: var(--primary);
}

.match-gallery-info .match-compatibility {
    font-size: 0.9rem;
    font-weight: bold;
    color: var(--accent);
    margin-bottom: 1rem;
}

.btn-view-product {
    font-family: 'Playpen Sans', sans-serif;
    font-size: 0.9rem;
    padding: 0.6rem 1rem;
    border: 1px solid var(--border-subtle);
    background: transparent;
    color: var(--text-light);
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-view-product:hover {
    border-color: var(--accent);
    background: rgba(204, 137, 86, 0.2);
    transform: translateY(-2px);
}

.no-matches-message {
    font-size: 1.2rem;
    color: var(--text-secondary);
    font-style: italic;
    min-height: 40vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

.results-actions {
    margin-top: auto; /* Pousse les boutons en bas */
    padding-top: 2rem;
}
/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Galerie des Matchs ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Visuel Match Profil (v2) ========= */
/* ========================================================== */

.profile-match-visual {
    display: flex; /* ✅ On utilise flex pour le positionnement */
    justify-content: center; /* ✅ Centrage horizontal */
    position: relative;
    margin: 0 auto 2rem; /* Centre l'élément et ajoute une marge en dessous */
    filter: drop-shadow(0 10px 30px rgba(0,0,0,0.5));
    width: 150px; /* Largeur totale de l'ensemble */
    height: 100px; /* Hauteur totale */
}

.profile-match-visual .profile-match-logo,
.profile-match-visual .profile-match-meat {
    width: 100px; /* ✅ Taille réduite des cercles */
    height: 100px; /* ✅ Taille réduite des cercles */
    border-radius: 50%;
    border: 3px solid var(--primary); /* ✅ Bordure plus fine */
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 25px var(--glow); /* ✅ Ombre plus subtile */
    position: absolute;
    top: 0;
}

.profile-match-visual .profile-match-logo {
    transform: translateX(-20px); /* ✅ Décale le logo à gauche */
    z-index: 1;
    background-color: var(--dark);
}

.profile-match-visual .profile-match-meat {
    transform: translateX(62px); /* ✅ Décale le morceau à droite */
    z-index: 2; /* ✅ Assure que le morceau passe devant */
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Visuel Match Profil (v2) ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC MODIFIÉ : Style du bouton "Mes SMASHS" ========= */
/* ========================================================== */

#view-matches-btn {
    display: none; /* Toujours contrôlé par JS */
    background: rgba(237, 193, 150, 0.05); /* ✅ Fond identique aux icônes */
    border: 1px solid var(--border-subtle); /* ✅ Bordure identique aux icônes */
    color: var(--text-secondary); /* ✅ Couleur identique aux icônes */
    height: 38px; /* ✅ Hauteur légèrement réduite pour l'esthétique */
    padding: 0 1.2rem; /* ✅ Padding horizontal pour que la boîte s'adapte au texte */
    font-size: 0.8rem; /* ✅ Texte plus petit et plus fin */
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-family: 'Loyola Pro Bold', serif;
    /* On retire les anciennes propriétés non nécessaires */
}
#view-matches-btn:hover {
    border-color: var(--accent); /* ✅ Effet de survol identique */
    background: rgba(204, 137, 86, 0.15);
    transform: translateY(-2px);
    color: var(--primary);
}

/* ========================================================== */
/* ========= FIN DU BLOC MODIFIÉ : Style du bouton "Mes SMASHS" ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC À AJOUTER : Bouton "Voir Mon Profil" (Résultats) ========= */
/* ========================================================== */

#view-profile-from-results-btn {
    background: transparent;
    border: 1px solid var(--border-subtle);
    color: var(--text-light);
    padding: 0.8rem 1.5rem;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-family: 'Loyola Pro Bold', serif;
    margin-bottom: 2.5rem; /* Espace avant le titre "Tes smashs" */
}

#view-profile-from-results-btn:hover {
    border-color: var(--accent);
    background: rgba(204, 137, 86, 0.15);
    transform: translateY(-2px);
    color: var(--primary);
}

/* ========================================================== */
/* ========= FIN DU BLOC À AJOUTER : Bouton "Voir Mon Profil" (Résultats) ========= */
/* ========================================================== */

    </style>
</head>
<body>

<!-- ========================================================== -->
<!-- ============== BLOC 2 : STRUCTURE HTML COMPLET =========== -->
<!-- ========================================================== -->

<div id="welcome-screen" class="view-container">
    <div class="welcome-content">
        <div class="welcome-logo"><img src="https://raw.githubusercontent.com/metscarnes/bimi-metscarnes/main/Logo%20Mets%20Carn%C3%A9s%20HD.png" alt="Logo"></div>
        <h1 class="welcome-title">SMASH 🔥</h1>
        <p class="welcome-description">Découvre ton morceau idéal.<br>Swipez, smatshez, dégustez.</p>
        <button id="start-btn" class="btn btn-welcome">🔥 Trouver mon smatch</button>
    </div>
</div>

<div id="app" class="view-container">
    <div class="container">
<header class="header">
            <div class="header-actions">
                <button id="back-btn" class="btn-icon" title="Retour" style="display: none;">⬅️</button>
                <button id="reset-btn" class="btn-icon" title="Recommencer">🔄</button>
            </div>
            <div class="main-title-wrapper">
                <h1 class="main-title">SMASHS 🔥</h1>
                <p class="subtitle">Ta Rencontre Charnelle</p>
<button id="view-matches-btn" style="display: none;">🏆 MES SMASHS</button>
            </div>
        </header>
        <main id="screen-root">
            <div id="intro-wrapper" class="screen"></div>
            <div id="question-flow" class="screen"></div>
            <div id="swipe-screen" class="screen"></div>
            <div id="results-screen" class="screen"></div>
            <!-- L'écran de profil sera ajouté ici par le JS -->
        </main>
    </div>
</div>

<div id="loading-screen" class="view-container">
    <div class="loading-content">
        <div class="loading-phase-1">
            <p class="loading-text"></p> <!-- ✅ Le texte est retiré, le JS s'en occupera entièrement -->
            <div class="loading-bar-container"><div class="loading-bar"></div></div>
        </div>
        <div class="loading-phase-2">
            <button id="reveal-btn" class="reveal-button">Découvrir les matchs</button>
        </div>
    </div>
</div>



<!-- ========================================================== -->
<!-- ========== DÉBUT DU BLOC À AJOUTER : Écran de Match ========== -->
<!-- ========================================================== -->

<div id="match-screen-overlay" class="modal-overlay">
    <div class="match-content-wrapper">
        <div class="pulse-bg pulse-1"></div>
        <div class="pulse-bg pulse-2"></div>
        <div class="pulse-bg pulse-3"></div>

        <div class="match-pfps">
            <div id="user-match-pfp" class="match-pfp"></div>
            <div id="meat-match-pfp" class="match-pfp"></div>
        </div>
        
        <h1 class="match-title">Match !</h1>
        <p id="match-subtitle" class="match-subtitle"></p>

        <!-- ✅ BOUTON AJOUTÉ CI-DESSOUS -->
        <button id="view-profile-btn" class="btn btn-match-profile">Découvrir mon profil</button>
<!-- ✅ BOUTON AJOUTÉ CI-DESSOUS -->
<button id="continue-swiping-btn-match" class="btn">Continuer à Swiper</button>
    </div>
</div>

<!-- ========================================================== -->
<!-- =========== FIN DU BLOC À REMPLACER : Écran de Match =========== -->
<!-- ========================================================== -->

<!-- ========================================================== -->
<!-- =========== FIN DU BLOC À AJOUTER : Écran de Match =========== -->
<!-- ========================================================== -->








<!-- ✅ MODAL D’ALERTE GLOBAL -->
<div class="modal-overlay" id="alert-modal">
  <div class="modal-content" style="background:#1a1614;color:#F5F1E8;padding:1.5rem;border-radius:8px;max-width:400px;margin:auto;text-align:center;">
    <h2 id="alert-modal-title"></h2>
    <p id="alert-modal-text" style="margin-top:1rem;margin-bottom:1.5rem;"></p>
    <div id="alert-modal-buttons"></div>
  </div>
</div>

<!-- ========================================================== -->
<!-- =========== BLOC 3 : SCRIPT JAVASCRIPT COMPLET =========== -->
<!-- ========================================================== -->
<script>
/* ============================================================ */
/* 🧭 MODE DEBUG NARRATIF M.E.T.S                                */
/* ============================================================ */
// let DEBUG_MODE = true; // ✅ Ligne supprimée, le debug est maintenant conditionnel


document.addEventListener('DOMContentLoaded', () => {
(function() {

    const state = {
        user: { nom: "", genre: "", city: "", styleNarratif: "neutre" },
        userAnswers: {},
        profile: { Destination: undefined, Tendrete: 5, Gout: 5, Jutosite: 5, Persillage: 5, interdits: null },
        deck: [],
        matches: [],
        convergenceMatches: [],
        swipedProductNames: new Set(),
        lastSwipedCard: null,
        currentStep: 0,
        consecutiveNameErrors: 0, 
        profileHistory: [], 
        currentScreen: null,
        loggedProducts: new Set(),
        isAnimating: false,
        swipeHistory: [],
        lastHintPresented: null,
        hasNewHint: false,
    };

const DOM = {
        views: { welcome: document.getElementById('welcome-screen'), app: document.getElementById('app'), loading: document.getElementById('loading-screen') },
        appScreens: { 
            intro: document.getElementById('intro-wrapper'), 
            questions: document.getElementById('question-flow'), 
            swipe: document.getElementById('swipe-screen'), 
            results: document.getElementById('results-screen'),
            profile: null
        },
        buttons: { start: document.getElementById('start-btn'), reveal: document.getElementById('reveal-btn'), reset: document.getElementById('reset-btn'), home: document.getElementById('home-btn') },
        modals: { 
    alert: document.getElementById('alert-modal'),
            alertTitle: document.getElementById('alert-modal-title'), // ✅ Ajouté
            alertText: document.getElementById('alert-modal-text'),   // ✅ Ajouté
            alertButtons: document.getElementById('alert-modal-buttons'), // ✅ Ajouté
            product: document.getElementById('product-modal-overlay') 
        },
        loadingBar: document.querySelector('.loading-bar'),
        feedbackToast: document.getElementById('feedback-toast'),
    };

// ✅ CORRECTION : 227 avec url
    const ALL_PRODUCTS = [  
];


// ==========================================================
// ============ BLOC DE FONCTIONS D'AFFICHAGE RESTAURÉES ET CORRIGÉES ============
// ==========================================================

function showView(v) { 
    Object.values(DOM.views).forEach(e => e.classList.remove('is-visible')); 
    if (v && DOM.views[v]) DOM.views[v].classList.add('is-visible'); 
}

function showAppScreen(s) {
    state.currentScreen = s;
    Object.values(DOM.appScreens).forEach(e => { if (e) {e.classList.remove('active'); e.style.display = 'none';} });
    
    const backBtn = document.getElementById('back-btn');
    if (backBtn) {
        backBtn.style.display = (s === 'questions' || s === 'swipe' || s === 'profile' || s === 'results') ? 'flex' : 'none';
    }

    if (s && DOM.appScreens[s]) {
        const t = DOM.appScreens[s];
        t.style.display = ['swipe', 'intro', 'questions', 'profile', 'results'].includes(s) ? 'flex' : 'block';
        t.classList.add('active');
    }
const viewMatchesBtn = document.getElementById('view-matches-btn'); // ✅ Nouvelle logique centralisée
    if (viewMatchesBtn) {
        const shouldShow = (s === 'swipe' && state.convergenceMatches.length > 0);
        viewMatchesBtn.style.display = shouldShow ? 'block' : 'none';
    }
}

function transitionToApp() { 
    showView('app'); 
    showAppScreen('intro'); 
    renderIntro(); 
}

/* ========================================================== */
/* ========= DÉBUT DU BLOC À DÉPLACER : renderSwipe ========= */
/* ========================================================== */

function renderSwipe() {
    DOM.appScreens.swipe.innerHTML = `
        <button id="view-matches-btn" style="display: none;">🏆 MES SMASHS</button>
        <div class="convergence-gauge-container">
            <div class="convergence-gauge-label">
                Affinement du profil
                <span id="convergence-help-btn" class="help-icon" title="Comment ça marche ?">?</span>
                <span id="coach-popup">votre coach a des astuces pour vous ! ➔</span>
            </div>
            <div class="convergence-gauge-bar">
                <div class="convergence-gauge-fill" id="convergence-fill"></div>
            </div>
            <div class="convergence-gauge-percent" id="convergence-percent">0%</div>
        </div>
        <div id="feedback-toast" class="feedback-toast"></div>
        <div class="card-deck" id="card-deck"></div>
        <div class="actions">
            <button class="action-btn undo" id="undo-btn">↩️</button>
            <button class="action-btn dislike" id="dislike-btn">❌</button>
            <button class="action-btn like" id="like-btn">❤️</button>
        </div>`;
    
    bindSwipeEvents(); 
    
    document.getElementById('convergence-help-btn').addEventListener('click', () => {
        const hint = generateConvergenceHint();
        showCustomAlert(hint);
        state.hasNewHint = false;
        state.lastHintPresented = hint.text;
        updateConvergenceGauge();
    });

    state.profileHistory = [];
    state.lastSwipedCard = null;
    if (state.deck.length === 0) {
        refreshDeck();
    }
    addNextCardToDeckIfNeeded();
    addNextCardToDeckIfNeeded();
    updateCardStates();
    updateConvergenceGauge();
}

/* ========================================================== */
/* ========= FIN DU BLOC À DÉPLACER : renderSwipe ========= */
/* ========================================================== */

/* ========================================================== */
/* ========= DÉBUT DU BLOC MODIFIÉ : transitionToLoading (Avec Animations JS) ========= */
/* ========================================================== */

function transitionToLoading() {
    showView('loading');
    const loadingTextEl = document.querySelector('.loading-text');
    const totalDuration = LOADING_MESSAGES.length * 1500; // ✅ Durée totale calculée dynamiquement
    let messageIndex = 0;
    let intervalId;

    DOM.loadingBar.style.transition = 'none';
    DOM.loadingBar.style.width = '0%';
    void DOM.loadingBar.offsetWidth;
    
    anime({
        targets: DOM.loadingBar,
        width: '100%',
        duration: totalDuration, // ✅ La barre se synchronise sur la durée totale des messages
        easing: 'linear'
    });

    const changeMessage = () => {
        // Étape 1: Animer la sortie du texte actuel
        anime({
            targets: loadingTextEl,
            opacity: 0,
            translateY: -10, // ✅ Le texte monte pour sortir
            duration: 400,
            easing: 'easeInQuad',
            complete: () => {
                messageIndex++; // On passe au message suivant
                if (messageIndex >= LOADING_MESSAGES.length) {
                    clearInterval(intervalId); // On arrête si on a affiché tous les messages
                    return;
                }
                
                // Étape 2: Changer le texte quand il est invisible
                loadingTextEl.textContent = LOADING_MESSAGES[messageIndex];

                // Étape 3: Animer l'entrée du nouveau texte
                anime({
                    targets: loadingTextEl,
                    opacity: 1,
                    translateY: 0, // ✅ Le texte revient à sa position
                    duration: 400,
                    easing: 'easeOutQuad'
                });
            }
        });
    };

    // Initialisation : Affiche le premier message avec une animation d'entrée
    loadingTextEl.textContent = LOADING_MESSAGES[0];
    anime({
        targets: loadingTextEl,
        opacity: [0, 1],
        translateY: [10, 0], // ✅ Le premier texte vient d'en bas
        duration: 500
    });

    // Lance le cycle de changement après que le premier message ait eu le temps de s'afficher
    intervalId = setInterval(changeMessage, 1500); // ✅ Change de message toutes les 1.5 secondes

    // Transition finale vers l'application
    setTimeout(() => {
        clearInterval(intervalId); // Sécurité pour arrêter l'intervalle
        DOM.views.loading.classList.add('is-opening');
        setTimeout(() => {
            showView('app');
            showAppScreen('swipe');
            renderSwipe();
            DOM.views.loading.classList.remove('is-opening');
        }, 1000);
    }, totalDuration); // ✅ On attend que tous les messages soient passés
}

/* ========================================================== */
/* ========= FIN DU BLOC MODIFIÉ : transitionToLoading (Avec Animations JS) ========= */
/* ========================================================== */

let feedbackTimeout;
function showFeedbackMessage(message) {
    const currentToast = document.getElementById('feedback-toast');
    if (!currentToast) return;

    clearTimeout(feedbackTimeout);
    currentToast.textContent = message;
    currentToast.classList.add('is-visible');
    feedbackTimeout = setTimeout(() => {
        currentToast.classList.remove('is-visible');
    }, 10000);
}

    const NUTRITIONAL_INFO_MAP = [ { key: 'Energie', label: 'Énergie', unit: 'kcal' }, { key: 'Proteines', label: 'Protéines', unit: 'g' }, { key: 'Lipides', label: 'Lipides', unit: 'g' }, { key: 'Glucides', label: 'Glucides', unit: 'g' }, { key: 'Sel', label: 'Sel', unit: 'g' }, { key: 'Fer', label: 'Fer', unit: 'mg' }, { key: 'Zinc', label: 'Zinc', unit: 'mg' }, { key: 'Selenium', label: 'Sélénium', unit: 'µg' }, { key: 'VitamineB12',label: 'Vitamine B12', unit: 'µg' } ];
    





const MATCH_PHRASES = [
    "Apparemment, {prenom}, tous tes choix de vie t'ont mené{e} inexorablement vers {produit_avec_article}. Étonnant. 🤷",
    "C'est acté. {produit_avec_article} et toi {prenom}, c'est plus crédible que ton dernier crush Tinder.",
    "Félicitations, {prenom}. T'as trouvé ta moitié... pour le dîner. C'est déjà ça de pris. 😉",
    "On dirait bien que {produit_avec_article} est le seul morceau qui supporte ton mordant. Profites-en, {prenom}. 😜",
    "C'est un match ! {prenom}, t'as ENFIN quelqu'un à présenter à tes parents : {produit_avec_article}. 🙏",
    "Certains trouvent l'amour. Toi {prenom}, t'as trouvé {produit_avec_article}. Bon, c'est déjà ça. 🥲",
    "Voilà, {prenom}. Ta quête de sens s'arrête ici. Sur un lit de... {produit_avec_article}. Pas mal non ? C'est Français ? 😏",
    "Certains trouvent l'âme sœur. Toi, {prenom}, t'as trouvé {produit_avec_article}. Chacun ses priorités. 🎯",
    "Après une analyse psychologique poussée, il s'avère que t'avais juste besoin de {produit_avec_article} dans ta vie, {prenom}. 🤓",
"C'est officiel ! {prenom} et {produit_avec_article}, c'est une love story. Enfin, pour 20 minutes. 🥳",
    "De rien hein, {prenom}. On t'a juste trouvé le seul plat capable de te faire plaisir : {produit_avec_article}. Facile. 💅",
    "Finalement, {prenom}, tout ce temps passé à swiper n'aura pas été vain. Tu repars avec {produit_avec_article}. 🏆",
    "Eh bien {prenom}, {produit_avec_article} a craqué pour ton charme. Ou ta CB. Sûrement ta CB. 😏",
    "Le verdict est tombé : t'es coupable d'avoir un match parfait avec {produit_avec_article}. 😋",
    "Arrête de chercher, {prenom}. Ce soir, c'est {produit_avec_article} et demain... on verra 😉 (Je suis fatigué patron)."
];


const PROFILE_PUNCHLINES = [
    "En résumé : t'as des goûts ... suspects . Mais au moins t'assumes.",
    "Conclusion : Ton palais sait ce qu'il veut, et il n'est pas du genre à faire des compromis.",
    "En gros : t'assumes tes choix douteux. Et franchement, on respecte l'audace.",
    "Pour faire simple : si ça ne se mange pas saignant, ça ne vous intéresse probablement pas.",
    "En bref : vous êtes un{e} puriste. Le genre de personne qui ne met pas de glaçons dans un bon vin."
];
    const QUESTION_STEPS = [
        { id: "intention", label: "1/6", text: "Ce soir, on part sur quoi ?", helper: "Un coup de foudre gustatif ou une histoire à mijoter ?", icons: ["⚡", "🍲", "😏"], options: [{ txt: "Coup de foudre", set: { Destination: "A griller" } }, { txt: "Mijotage lent", set: { Destination: "A mijoter" } }, { txt: "Surprends-moi", set: { Destination: null } }] },
        { id: "energie", label: "2/6", text: "Quelle est ton énergie du moment ?", helper: "Plutôt feu de grill ou cocon tranquille ce soir ?", icons: ["🔥", "🌙", "😋"], options: [{ txt: "Feu de grill", apply: () => { state.profile.Gout += 2; state.profile.Jutosite += 1; } }, { txt: "Douceur du soir", apply: () => { state.profile.Tendrete += 2; state.profile.Jutosite += 1; } }, { txt: "Juste faim", apply: () => { state.profile.Gout += 1; } }] },
        { id: "rapport", label: "3/6", text: "Plutôt direct ou tout en douceur ?", helper: "Tu aimes les morceaux francs ou ceux qui demandent de l'attention ?", icons: ["🥩", "🍖", "🌤️"], options: [{ txt: "Franc et direct", apply: () => { state.profile.Tendrete = Math.max(4, state.profile.Tendrete); state.profile.Persillage = Math.max(4, state.profile.Persillage); } }, { txt: "Fondant et patient", apply: () => { state.profile.Tendrete = Math.max(7, state.profile.Tendrete); } }, { txt: "Selon l'humeur", apply: () => {} }] },
        { id: "exploration", label: "4/6", text: "Voyage ou terroir ?", helper: "On reste dans les classiques ou on se laisse tenter par l'exotisme ?", icons: ["🇫🇷", "🌍", "👀"], options: [{ txt: "Classiques", set: { ouvertureExotique: false } }, { txt: "Curieux", set: { ouvertureExotique: true } }, { txt: "Les deux", set: { ouvertureExotique: "mixte" } }] },
        { id: "partage", label: "5/6", text: "Pour toi... ou pour partager ?", helper: "Tu partages, ou tu gardes tout pour toi ? 😏", icons: ["💞", "😋", "😇"], options: [{ txt: "Je partage", set: { partage: "partage" } }, { txt: "Je garde", set: { partage: "garde" } }, { txt: "Ça dépend", set: { partage: "depend" } }] },
        { id: "interdits", label: "6/6", text: "Avant que je fasse une boulette...", helper: "Des viandes que tu ne veux pas voir ?", type: "multi" }
    ];
    const ESPECES = [ { name: "Aucune restriction", emoji: "😋" },{ name: "Porc", emoji: "🐷" }, { name: "Cheval", emoji: "🐎" }, { name: "Viande exotique", emoji: "🐊" }, { name: "Gibier", emoji: "🦌" }, { name: "Agneau", emoji: "🐑" }, { name: "Bœuf", emoji: "🐄" }, { name: "Veau", emoji: "🐮" }, { name: "Volaille", emoji: "🐔" } ];
    const LOADING_MESSAGES = 
["Le gras c'est la vie", 
"On analyse tes choix de vie", 
"Je suis fatigué patron"];

    function formatProduitAvecArticle(produitBrut) {
      if (!produitBrut) return "";
      const p = produitBrut.trim();
      const lower = p.toLowerCase();
      const voyelles = "aàâäeéèêëiïîoôöuùûüyh";
      if (voyelles.includes(lower[0])) return "l’" + lower;
      const femCandidats = ["aiguillette", "araignée", "bavette", "côte", "cote", "poitrine", "épaule", "selle", "viande"];
      if (femCandidats.some(f => lower.startsWith(f))) return "la " + lower;
      return "le " + lower;
    }

function formatText(template, data) {
    if (!template) return "";
    let result = template;
    for (const key in data) {
        const regex = new RegExp(`\\{${key}\\}`, 'g');
        result = result.replace(regex, data[key]);
    }
    return result;
}

    const memory = { lastPhrase: "", lastActions: [], lastIntro: "", lastSujet: "", lastVerbe: "", lastCompl: "", lastPonct: "" };
    const GABARITS = {
        intros: {
            like: {
                exploration: ["Intéressant. Première donnée pertinente enregistrée", "OK, un premier point de données. On verra où ça mène", "Un choix. Pas forcément bon ou mauvais, juste un choix", "D'accord, on part sur cette base. Pour l'instant"],
                confirmation: ["Ah. Un schéma se dessine. Prévisible", "Confirmation de la tendance. L'algorithme apprécie", "Prévisible. Mais dans le bon sens du terme", "Cohérent. J'aime la cohérence. C'est reposant", "On reste sur le même cap. Efficace"],
                conclusion: ["Bon, le profil est établi. Pas de surprises", "Verdict : profil identifié. Simple, en fait", "On a assez de données pour porter un jugement. Et le jugement est : bon", "Analyse terminée. C'est clair comme de l'eau de roche"]
            },
            dislike: {
                exploration: ["Noté. Une première piste écartée", "OK. On sait ce que tu n'es pas. C'est un début", "Première information par la négative. Utile", "Bien. L'élimination est une méthode valide"],
                confirmation: ["La tendance au rejet se confirme. Intéressant", "Cohérent dans le refus. Au moins, tu es décidé(e)", "Encore un 'non'. Tes critères de sélection sont... stricts", "Le périmètre se resserre. C'est mathématique", "Noté. Et classé sans suite"],
                conclusion: ["Profil par exclusion complété. On sait ce qu'il te faut : pas ça", "Le portrait-robot de tes aversions est terminé", "Analyse terminée. Tes 'non' sont plus éloquents que tes 'oui'", "Bon. Ça, c'est une information. Une information très claire"]
            }
        },
        sujets: {
            Gout_Persillage: [{ text: "la faction des 'plus de goût, moins de questions'", isPlural: false }, { text: "le choix de ceux qui ont déjà lu la fin du livre", isPlural: false }, { text: "le parti pris de la saveur maximale", isPlural: false }, { text: "la stratégie 'haut risque, haute récompense'", isPlural: false }, { text: "la recherche de la vérité... dans le gras", isPlural: false }, { text: "le principe de 'cause à effet' culinaire", isPlural: false }, { text: "l'investissement dans le capital-saveur", isPlural: false }, { text: "le théorème du goût qui l'emporte toujours", isPlural: false }],
            Tendrete_Jutosite: [{ text: "la doctrine du 'moindre effort buccal'", isPlural: false }, { text: "l'option 'zéro prise de tête'", isPlural: false }, { text: "le choix qui évite les débats et les couteaux mal aiguisés", isPlural: false }, { text: "le plan de secours qui devient le plan A", isPlural: false }, { text: "la philosophie du 'ça va bien se passer'", isPlural: false }, { text: "le kit de démarrage pour un repas sans incident", isPlural: false }, { text: "la zone de confort, mais en version comestible", isPlural: false }, { text: "le choix anti-stress par excellence", isPlural: false }],
            Equilibre: [{ text: "le classique 'ça marche à chaque fois'", isPlural: false }, { text: "le choix par défaut de l'univers", isPlural: false }, { text: "le summum du pragmatisme", isPlural: false }, { text: "le bon sens transformé en dîner", isPlural: false }, { text: "la loi du 80/20 appliquée à {possessif_s} assiette", isPlural: false }, { text: "la solution qui fonctionne, fin de la discussion", isPlural: false }, { text: "le couteau suisse de {possessif_s} appétit", isPlural: false }, { text: "cette tendance un peu trop évidente chez toi", isPlural: false }, { text: "l'algorithme interne de la faim", isPlural: false }, { text: "le système d'exploitation de {possessif_s} estomac", isPlural: false }, { text: "{possessif_s} historique de décisions alimentaires", isPlural: false }, { text: "ce morceau qui a probablement son propre fan club", isPlural: false }, { text: "la mise à jour de {possessif_p} propres certitudes", isPlural: false }],
            all_styles: [{ text: "{possessif_s} instinct primaire qui a pris le dessus", isPlural: false }, { text: "la petite voix bureaucratique dans ta tête qui a dit 'approuvé'", isPlural: false }, { text: "le diagramme de Venn entre 'j'ai faim' et 'maintenant'", isPlural: false }, { text: "le point final de {possessif_s} appétit", isPlural: false }, { text: "ce choix, probablement sponsorisé par la logique", isPlural: false }, { text: "l'anomalie dans {possessif_s} régime alimentaire", isPlural: false }, { text: "{possessif_s} subconscient qui a faim et qui est pressé", isPlural: false }, { text: "le plan A, parce que le plan B implique une salade", isPlural: false }, { text: "la définition du mot 'inévitable'", isPlural: false }, { text: "ce réflexe conditionné par des millénaires d'évolution", isPlural: false }, { text: "la pièce maîtresse de la chaîne alimentaire personnelle", isPlural: false }, { text: "le concept même de 'ne pas se poser de questions'", isPlural: false }]
        },
        verbes: {
            like: [
                { root: "valider", adverb: "cette hypothèse" },
                { root: "confirmer", adverb: "ce qui était déjà une évidence" },
                { root: "cibler", adverb: "avec une efficacité redoutable" },
                { root: "officialiser", adverb: "{possessif_s} penchant pour ce style" },
                { root: "optimiser", adverb: "le ratio plaisir/temps" },
                { root: "court-circuiter", adverb: "toute autre possibilité" },
                { root: "pointer", adverb: "directement vers la solution" },
                { root: "sélectionner", adverb: "comme si c'était le seul choix logique" },
                { root: "prioriser", adverb: "l'essentiel" },
                { root: "trancher", adverb: "sans la moindre hésitation" },
                { root: "aligner", adverb: "sur {possessif_p} principes fondamentaux" },
                { root: "calibrer", adverb: "{possessif_p} préférences futures" },
                { root: "authentifier", adverb: "{possessif_s} statut de connaisseur" },
                { root: "condenser", adverb: "{possessif_p} envies en une seule image" },
                { root: "exécuter", adverb: "le plan sans accroc" }
            ],
            dislike: [
                { root: "rejeter", adverb: "avec une logique implacable" },
                { root: "ignorer", adverb: "comme un appel d'un numéro masqué" },
                { root: "invalider", adverb: "cette proposition" },
                { root: "filtrer", adverb: "sans pitié" },
                { root: "écarter", adverb: "comme une théorie du complot" },
                { root: "mettre", adverb: "sur la liste d'attente... pour toujours" },
                { root: "archiver", adverb: "dans la catégorie 'fausse bonne idée'" },
                { root: "déclasser", adverb: "cette option" },
                { root: "refuser", adverb: "avec la politesse d'un e-mail automatique" },
                { root: "bloquer", adverb: "l'accès à {possessif_s} assiette" },
                { root: "passer", adverb: "directement à la suite" },
                { root: "réfuter", adverb: "cet argument par l'action" },
                { root: "annuler", adverb: "ce contrat tacite" },
                { root: "purger", adverb: "de la liste des options viables" },
                { root: "éviter", adverb: "comme une réunion le vendredi après-midi" }
            ]
        },
        complements: {
            Bœuf: ["avec la certitude tranquille de ceux qui ont raison", "comme un classique du rock, ça ne vieillit jamais", "parce que parfois, il n'y a pas besoin de réinventer la roue", "avec la subtilité d'un tank qui livre des fleurs", "le choix par défaut de l'humanité depuis 10 000 ans", "la solution à 99% des problèmes qui impliquent d'avoir faim", "un vote pour la tradition et le bon gras", "la version comestible d'un fauteuil confortable", "parce que 'salade' a rarement rendu quelqu'un heureux", "le point Godwin de la faim"],
            Porc: ["plus fiable que ton Wi-Fi", "parce que le croustillant est une forme d'art", "la preuve que les choses simples sont les meilleures", "le couteau suisse de la cuisine", "un choix qui sent bon le dimanche midi", "la définition même du mot 'gourmandise'", "ça se marie avec tout, même avec plus de porc", "le doudou comestible de l'humanité", "la réponse économique à une question existentielle"],
            Volaille: ["le choix qui ne déclenchera pas de guerre familiale", "la diplomatie par l'assiette", "la toile blanche de tes talents de cuisinier", "parce que des fois, on veut juste manger sans réfléchir", "le mode 'sans échec' de la cuisine", "un choix si raisonnable que c'en est presque suspect", "la preuve qu'on peut être léger et délicieux", "le champion de la polyvalence", "le morceau qui met tout le monde d'accord, même les gens bizarres", "le 'ça passe' qui devient un 'c'est excellent'"],
            default: ["parce que le gras, c'est l'information qui donne le goût à la vie", "avec la certitude de quelqu'un qui a raison sur Internet", "comme un fichier .zip de saveur pure", "c'est pas une opinion, c'est un fait", "la solution élégante à un problème primaire", "un choix qui met fin à tous les débats", "parce que la vie est trop courte pour les viandes fades", "une décision logique et inévitable", "ça coche toutes les cases", "un investissement à court terme pour un bonheur immédiat", "la quintessence du 'j'ai faim'", "le genre de choix qui fait hocher la tête des connaisseurs", "une évidence mathématique", "c'est propre, c'est net, c'est sans bavure", "le sommet de la pyramide alimentaire, tout simplement"]
        }
    };
    function conjugateVerb(root, isPlural) {
        if (isPlural) {
            if (root.endsWith('er')) return root.slice(0, -2) + 'ent';
            if (root.endsWith('ir')) return root.slice(0, -2) + 'issent';
            return root + 'ent';
        } else {
            if (root.endsWith('er')) return root.slice(0, -2) + 'e';
            if (root.endsWith('ir')) return root.slice(0, -2) + 'it';
            if (root.endsWith('tre')) return root.slice(0, -2); 
            return root;
        }
    }
function buildGrammaticalSentence(sujetData, verbeData, complText, user) {
    const useTutoiement = (user?.nom?.trim() || "vous") !== "vous";
    const conjugated = conjugateVerb(verbeData.root, sujetData.isPlural);
    const pronoun = useTutoiement ? (/^[aeiouhàâéèê]/i.test(conjugated) ? "t'" : "te ") : "vous ";
    
    const formatData = {
        possessif_s: useTutoiement ? "ton" : "votre",
        possessif_p: useTutoiement ? "tes" : "vos",
        prenom: user.nom ? user.nom.charAt(0).toUpperCase() + user.nom.slice(1) : "vous"
    };

    const sujetText = formatText(sujetData.text, formatData);
    const mainClause = `${sujetText} qui ${pronoun}${conjugated}`;
    const adverbPart = verbeData.adverb ? ` ${formatText(verbeData.adverb, formatData)}` : "";

    return `${mainClause}${adverbPart}, ${complText}`;
}

    function pickUnique(arr, lastValue) {
        if (!arr || !arr.length) return "";
        let choice;
        let safety = 0;
        do { choice = arr[Math.floor(Math.random() * arr.length)]; safety++; } 
        while (choice === lastValue && arr.length > 1 && safety < 15);
        return choice;
    }
    const narrativeMemory = { lastPhase: null, streakLikes: 0, streakDislikes: 0 };
    function updateNarrativeStyle(state, memory) {
        const actions = (memory.lastActions || []).slice(-6);
        if (actions.length < 3) return state.user.styleNarratif;
        const likes = actions.filter(a => a.action === "like").length;
        const dislikes = actions.filter(a => a.action === "dislike").length;
        const sameCategory = actions.every(a => a.categorie === actions[0].categorie);
        const categories = [...new Set(actions.map(a => a.categorie))];
        const consistency = sameCategory || categories.length <= 2;
        let newStyle = state.user.styleNarratif || "sobre";
        if (likes >= 4 && !consistency) newStyle = "curieux";
        else if (likes >= 4 && consistency) {
            if (newStyle === "sobre") newStyle = "complice";
            else if (newStyle === "complice") newStyle = "romantique";
            else newStyle = "complice";
        } else if (dislikes >= 3) newStyle = "humoristique";
        else if (likes >= 2 && dislikes >= 2) newStyle = "sobre";
        if (newStyle !== state.user.styleNarratif) {
            console.log(`🎭 Style narratif évolue : ${state.user.styleNarratif} → ${newStyle}`);
            state.user.styleNarratif = newStyle;
        }
        return newStyle;
    }
    function adaptNarrativeTone(phase, action) {
        let prefix = "", suffix = "";
        if (action === "like") {
            const suffixes = ["Ça devient intéressant.", "Je crois qu’on touche juste.", "Continue comme ça.", "Bon réflexe.", "C'est noté.", "On est sur la bonne voie.", "Excellent choix."];
            suffix = " " + suffixes[Math.floor(Math.random() * suffixes.length)];
            narrativeMemory.streakLikes++;
            narrativeMemory.streakDislikes = 0;
        } else {
            narrativeMemory.streakDislikes++;
            narrativeMemory.streakLikes = 0;
        }
        if (narrativeMemory.streakLikes >= 3 && phase !== "conclusion") {
            const streakPrefixes = ["On commence à bien se comprendre.", "Je te vois venir...", "On est presque en phase.", "Tes goûts sont constants."];
            prefix = streakPrefixes[Math.floor(Math.random() * streakPrefixes.length)];
            narrativeMemory.streakLikes = 0;
        }
        if (narrativeMemory.streakDislikes >= 3) {
            const streakPrefixes = ["Difficile à séduire.", "Tu es exigeant(e), dis-moi.", "Rien ne semble te plaire aujourd'hui ?", "La quête du morceau parfait est ardue."];
            prefix = streakPrefixes[Math.floor(Math.random() * streakPrefixes.length)];
            narrativeMemory.streakDislikes = 0;
        }
        narrativeMemory.lastPhase = phase;
        return { prefix: prefix, suffix: suffix };
    }
    function detectNarrativeStyle(user) {
        const name = (user.nom || "").toLowerCase();
        const genre = user.genre?.toLowerCase() || "";
        if (name.includes("r2") || name.includes("bot") || name.includes("robot")) return "humoristique";
        if (genre === "madame") return "romantique";
        if (genre === "monsieur" && name.endsWith("o")) return "complice";
        if (name.endsWith("ine") || name.endsWith("elle")) return "curieux";
        return "sobre";
    }
    function buildDynamicSentence(user, profile, phase, action, meatCategory) {
        const allSujets = [...GABARITS.sujets.Gout_Persillage, ...GABARITS.sujets.Tendrete_Jutosite, ...GABARITS.sujets.Equilibre, ...GABARITS.sujets.all_styles];
        const sujetData = pickUnique(allSujets, memory.lastSujet);
        memory.lastSujet = sujetData;
        const verbeData = pickUnique(GABARITS.verbes[action], memory.lastVerbe);
        memory.lastVerbe = verbeData;
        const complText = pickUnique(GABARITS.complements[meatCategory] || GABARITS.complements.default, memory.lastCompl);
        memory.lastCompl = complText;
        const baseSentence = buildGrammaticalSentence(sujetData, verbeData, complText, user);
        const tone = adaptNarrativeTone(phase, action);
        let intro, finalSentence;
        const ponctuation = pickUnique([".", "...", "!"])[0];
        if (tone.prefix) {
            intro = tone.prefix;
            finalSentence = `${intro.trim()} ${baseSentence.charAt(0).toUpperCase() + baseSentence.slice(1)}${ponctuation}${tone.suffix}`;
        } else {
            intro = pickUnique(GABARITS.intros[action][phase], memory.lastIntro);
            memory.lastIntro = intro;
            finalSentence = `${intro.trim()} : ${baseSentence}${ponctuation}${tone.suffix}`;
        }
        return finalSentence.replace(/\[?\s*prenom\s*\]?/gi, user?.nom?.trim() || "vous");
    }
    function generateNarrativeFeedback(user, profile, phase, action, meatCategory) {
        if (action === 'dislike') {
            return pickUnique([
                "C'est noté.", 
                "Message reçu, on affine.", 
                "Parfait, ça clarifie les choses.", 
                "Compris, on oublie celui-là.", 
                "Le choix se resserre."
            ]);
        }
        updateNarrativeStyle(state, memory);
        const baseSentence = buildDynamicSentence(user, profile, phase, action, meatCategory);
        return baseSentence;
    }
    async function requestLocation() { const s = () => { state.user.city = "Neuilly-Plaisance"; }; if (!navigator.geolocation) { s(); return; } try { const p = await new Promise((rs, rj) => navigator.geolocation.getCurrentPosition(rs, rj, { timeout: 5000 })); const { latitude: lat, longitude: lon } = p.coords; const rsp = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`); if (!rsp.ok) throw new Error(); const d = await rsp.json(); state.user.city = d.address.city || d.address.town || d.address.village || "Inconnu"; } catch (e) { s(); } }
    function calculateScore(p, pr) { let s = 0; const w = { tendrete: 0.3, gout: 0.3, jutosite: 0.15, persillage: 0.15, destination: 0.1 }; s += (1 - Math.abs(p.Tendrete - pr.Tendrete) / 10) * w.tendrete; s += (1 - Math.abs(p.Gout - pr.Gout) / 10) * w.gout; s += (1 - Math.abs(p.Jutosite - pr.Jutosite) / 10) * w.jutosite; s += (1 - Math.abs(p.Persillage - pr.Persillage) / 10) * w.persillage; if (pr.Destination && p.Destination.includes(pr.Destination)) s += 1 * w.destination; return s * 100 + (Math.random() * 5); }
    function getConvergenceDistance() {
        const history = state.profileHistory;
        if (history.length < 5) return Infinity; 
        const currentProfile = history[history.length - 1];
        const oldProfile = history[history.length - 5]; 
        if (!oldProfile) return Infinity;
        let distance = Math.abs(currentProfile.Tendrete - oldProfile.Tendrete) + 
                       Math.abs(currentProfile.Gout - oldProfile.Gout) + 
                       Math.abs(currentProfile.Jutosite - oldProfile.Jutosite) + 
                       Math.abs(currentProfile.Persillage - oldProfile.Persillage);
        return distance;
    }
function checkForConvergence() {
        const CONVERGENCE_THRESHOLD = 1.2; 
        const distance = getConvergenceDistance();
        if (state.user.nom === "ulyssecampiglia") console.log(`🔎 Convergence Check: Distance = ${distance.toFixed(2)} (Seuil: ${CONVERGENCE_THRESHOLD})`); // ✅ Correction
        return distance < CONVERGENCE_THRESHOLD;
    }
    function calculateConvergenceProgress() {
        const distance = getConvergenceDistance();
        const CONVERGENCE_THRESHOLD = 1.2;
        const MAX_DISTANCE_FOR_GAUGE = 8.0;
        if (distance <= CONVERGENCE_THRESHOLD) {
            return 100;
        }
        const progress = 100 * (1 - ((distance - CONVERGENCE_THRESHOLD) / (MAX_DISTANCE_FOR_GAUGE - CONVERGENCE_THRESHOLD)));
        return Math.max(0, Math.min(99, Math.round(progress)));
    }
    function updateConvergenceGauge() {
        const progress = calculateConvergenceProgress();
        const fillEl = document.getElementById('convergence-fill');
        const percentEl = document.getElementById('convergence-percent');
        if (fillEl && percentEl) {
            fillEl.style.width = `${progress}%`;
            percentEl.textContent = `${progress}%`;
        }
        const labelEl = document.querySelector('.convergence-gauge-label');
        if (labelEl) {
            if (state.hasNewHint) {
                labelEl.classList.add('has-hint');
            } else {
                labelEl.classList.remove('has-hint');
            }
        }
    }
    function getUniqueMatchPhrase() {
        if (!state.availableMatchPhrases || state.availableMatchPhrases.length === 0) {
            state.availableMatchPhrases = [...MATCH_PHRASES];
        }
        const randomIndex = Math.floor(Math.random() * state.availableMatchPhrases.length);
        const chosenPhrase = state.availableMatchPhrases.splice(randomIndex, 1)[0];
        return chosenPhrase;
    }

/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : triggerFinalMatchAnimation ========= */
/* ========================================================== */

function triggerFinalMatchAnimation(finalCard) {
    if (state.user.nom === "ulyssecampiglia") console.log("🎉 CONVERGENCE ATTEINTE ! Lancement de l'animation de Match."); // ✅ Correction
    const deck = document.querySelector('.card-deck');
    if (deck) deck.style.pointerEvents = 'none';

    const meatData = finalCard.meatData; // ✅ On garde les données du produit qui a matché

    const alreadyExists = state.convergenceMatches.some(match => match.product.Produit === meatData.Produit);
if (!alreadyExists) {
        const score = calculateScore(meatData, state.profile);
        state.convergenceMatches.push({ product: meatData, score: score });
        if (state.user.nom === "ulyssecampiglia") console.log(`🏆 Match de convergence ajouté : ${meatData.Produit}`); // ✅ Correction
    }
    
    const matchOverlay = document.getElementById('match-screen-overlay');
    const userPfp = document.getElementById('user-match-pfp');
    const meatPfp = document.getElementById('meat-match-pfp');
    const matchSubtitle = document.getElementById('match-subtitle');
    const viewProfileBtn = document.getElementById('view-profile-btn');
    const continueSwipingBtn = document.getElementById('continue-swiping-btn-match');

    if (!matchOverlay || !userPfp || !meatPfp || !matchSubtitle || !viewProfileBtn || !continueSwipingBtn) return;

    const closeMatchScreen = (callback) => {
        anime({
            targets: '.match-content-wrapper',
            opacity: 0,
            scale: 0.9,
            duration: 400,
            easing: 'easeInExpo',
            complete: () => {
                matchOverlay.classList.remove('is-visible');
                anime.set(['.match-pfp', '.match-title', '.match-subtitle', '.btn-match-profile', '#continue-swiping-btn-match', '.match-content-wrapper'], { opacity: 0, scale: 1, translateY: 0 });
                if (callback) callback();
            }
        });
    };

    const userLogoUrl = "https://raw.githubusercontent.com/metscarnes/bimi-metscarnes/main/Logo%20Mets%20Carn%C3%A9s%20HD.png";

    const formatData = {
        prenom: state.user.nom ? state.user.nom.charAt(0).toUpperCase() + state.user.nom.slice(1) : "Vous",
        produit_avec_article: formatProduitAvecArticle(meatData.Produit),
        e: state.user.genre === 'Madame' ? 'e' : ''
    };
    
    const phraseTemplate = getUniqueMatchPhrase();
    const finalPhrase = formatText(phraseTemplate, formatData);

    userPfp.style.backgroundImage = `url('${userLogoUrl}')`;
    meatPfp.style.backgroundImage = `url('${meatData.image_url || "https://via.placeholder.com/450x600/1a1614/d4b896?text=🥩"}')`;
    matchSubtitle.textContent = finalPhrase;

    const newProfileBtn = viewProfileBtn.cloneNode(true);
    viewProfileBtn.parentNode.replaceChild(newProfileBtn, viewProfileBtn);
    // ✅ LA CORRECTION EST ICI : On passe 'meatData' en paramètre.
    newProfileBtn.addEventListener('click', () => closeMatchScreen(() => renderProfileScreen(meatData))); 

    const newContinueBtn = continueSwipingBtn.cloneNode(true);
    continueSwipingBtn.parentNode.replaceChild(newContinueBtn, continueSwipingBtn);
    newContinueBtn.addEventListener('click', () => closeMatchScreen(() => { 
        showAppScreen('swipe'); 
        renderSwipe(); 
    }));

    matchOverlay.classList.add('is-visible');

    // ... (le reste de la fonction d'animation anime.js reste identique)
    const tl = anime.timeline({
        easing: 'easeOutExpo',
        duration: 800
    });

    tl.add({
        targets: '.match-content-wrapper',
        opacity: [0, 1]
    })
    .add({
        targets: '#user-match-pfp',
        translateX: 0,
        scale: 1,
        opacity: 1,
        rotate: '-10deg'
    }, '-=600')
    .add({
        targets: '#meat-match-pfp',
        translateX: 0,
        scale: 1,
        opacity: 1,
        rotate: '10deg'
    }, '-=600')
    .add({
        targets: '.match-title',
        translateY: 0,
        opacity: 1,
        duration: 600
    }, '-=400')
    .add({
        targets: '.match-subtitle',
        translateY: 0,
        opacity: 1,
        duration: 500
    }, '-=300')
    .add({
        targets: ['#view-profile-btn', '#continue-swiping-btn-match'],
        translateY: 0,
        opacity: 1,
        duration: 500,
        delay: anime.stagger(100, {start: 200})
    }, '-=200');
}

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : triggerFinalMatchAnimation ========= */
/* ========================================================== */

function refreshDeck() {
    if (state.user.nom === "ulyssecampiglia") { // ✅ Correction
        if (state.profile.interdits && state.profile.interdits.length > 0) {
            console.groupCollapsed(`🚫 Filtrage initial des produits basé sur le questionnaire`);
            const forbiddenCategories = state.profile.interdits;
            console.log(`Catégories interdites par l'utilisateur :`, forbiddenCategories);
            const excludedProducts = ALL_PRODUCTS.filter(p => forbiddenCategories.includes(p.Categorie));
            const excludedCounts = excludedProducts.reduce((acc, p) => {
                acc[p.Categorie] = (acc[p.Categorie] || 0) + 1;
                return acc;
            }, {});
            console.log("Détail des produits exclus par catégorie :");
            Object.entries(excludedCounts).forEach(([categorie, count]) => {
                console.log(`- ${categorie}: ${count} produits retirés`);
            });
            const totalInitial = ALL_PRODUCTS.length;
            const totalFinal = totalInitial - excludedProducts.length;
            console.log(`%cRésultat : ${totalInitial} produits au départ ➔ ${totalFinal} produits potentiels restants.`, 'color: #f9b930; font-weight: bold;');
            console.groupEnd();
        } else {
            console.log(`%c✅ Aucun filtre 'interdit' appliqué par l'utilisateur. Tous les types de produits sont inclus.`, 'color: #2de9a1;');
        }
    }

    const remaining = ALL_PRODUCTS.filter(p => 
        !state.swipedProductNames.has(p.Produit) && 
        !(state.profile.interdits || []).includes(p.Categorie)
    );

    if (remaining.length === 0) {
        state.deck = [];
        showFeedbackMessage("Vous avez vu tous les profils !");
        return;
    }

    const scored = remaining.map(p => ({ p, score: calculateScore(p, state.profile) }));
    scored.sort((a, b) => b.score - a.score);
    state.deck = scored.map(item => item.p);

    if (state.user.nom === "ulyssecampiglia") { // ✅ Correction
        console.log(`%c🔄 DECK CONSTRUIT`, 'color: #87CEEB; font-weight: bold;', `(${state.deck.length} cartes) Prochaines cartes : ${state.deck.slice(0, 3).map(p => p.Produit).join(', ')}`);
    }
}
    function calculateAndGetNextCard() {
        if (state.deck.length === 0) refreshDeck();
        return state.deck.shift() || null;
    }
    function adaptProfileOnMatch(m, p) { const l = p ? 0.3 : -0.1; for (const k of ['Tendrete', 'Gout', 'Jutosite', 'Persillage']) { if (m[k] !== undefined) { state.profile[k] += (m[k] - state.profile[k]) * l; state.profile[k] = Math.max(0, Math.min(10, state.profile[k])); } } }


/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : renderIntro (Structure HTML Corrigée) ========= */
/* ========================================================== */

function renderIntro() {
        DOM.appScreens.intro.innerHTML = `
            <div id="intro-step-1" class="intro-step is-active">
                <div id="dialogue">
                    <p>Bonjour 👋</p>
                    <p>Moi, c'est Ulysse... Et vous ?</p>
                </div>
                <div class="inputs">
                    <div class="buttons">
                        <button class="btn-genre" data-genre="Monsieur">Monsieur</button>
                        <button class="btn-genre" data-genre="Madame">Madame</button>
                    </div>
                    <input type="text" id="name-input" placeholder="Votre prénom">
                </div>
                <button class="btn" id="btn-next-step">C'est moi !</button>
            </div>
            <div id="intro-step-2" class="intro-step">
                <p id="intro-greeting" style="font-size: 1.5rem; margin-bottom: 2rem;"></p>
                <div class="buttons" style="justify-content: center; flex-wrap: wrap;">
                    <button class="btn" id="btn-full-start">
                        Guidez-moi <span style="font-size: 0.8em;">(Questionnaire)</span>
                    </button>
                    <button class="btn" id="btn-fast-start">
                        J'ai la dalle ! <span style="font-size: 0.8em;">(Swipe direct)</span>
                    </button>
                </div>
            </div>
        `;
        const style = document.createElement('style');
        style.textContent = `
            .intro-step { opacity: 0; transform: translateY(20px); transition: all 0.5s ease; pointer-events: none; position: absolute; }
            .intro-step.is-active { opacity: 1; transform: translateY(0); pointer-events: auto; position: relative; display: flex; flex-direction: column; align-items: center; gap: 1.5rem;}
            .intro-step.is-active .inputs { opacity: 1; }
        `;
        DOM.appScreens.intro.appendChild(style);
        bindIntroEvents();
    }

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : renderIntro (Structure HTML Corrigée) ========= */
/* ========================================================== */
function renderQuestionStep() {
    const s = QUESTION_STEPS[state.currentStep];
    if (!s) {
        transitionToLoading();
        return;
    }
    let a = s.type === "multi" ?
        `<div class="answers">${ESPECES.map(e => `<div class="answer-card small-text" data-value="${e.name}"><span class="icon">${e.emoji}</span><span class="text">${e.name}</span></div>`).join('')}</div><button class="btn" id="q-next">Continuer</button>` :
        `<div class="answers">${s.options.map((o, i) => `<div class="answer-card" data-index="${i}">${s.icons?`<span class="icon">${s.icons[i]}</span>`:''}<span class="text">${o.txt}</span></div>`).join('')}</div>`;
    
    DOM.appScreens.questions.innerHTML = `
        <div id="q-progress">Profil carné · ${s.label}</div>
        <h2 id="q-text">${s.text}</h2>
        ${s.helper?`<p class="question-helper">${s.helper}</p>`:''}
        ${a}
    `;
    bindQuestionEvents();
    
    const savedAnswerIndex = state.userAnswers[s.id];
    if (savedAnswerIndex !== undefined) {
        const answerCards = DOM.appScreens.questions.querySelectorAll('.answer-card');
        if (answerCards[savedAnswerIndex]) {
            answerCards[savedAnswerIndex].classList.add('selected');
        }
    }
}
/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : renderProfileScreen ========= */
/* ========================================================== */

function renderProfileScreen(triggeringMatchProduct) {
    if (!DOM.appScreens.profile) {
        const profileScreenEl = document.createElement('div');
        profileScreenEl.id = 'profile-screen';
        profileScreenEl.className = 'screen';
        document.getElementById('screen-root').appendChild(profileScreenEl);
        DOM.appScreens.profile = profileScreenEl;
    }

    const formatData = {
        prenom: state.user.nom ? state.user.nom.charAt(0).toUpperCase() + state.user.nom.slice(1) : "Vous",
        e: state.user.genre === 'Madame' ? 'e' : '',
        ne: state.user.genre === 'Madame' ? 'ne' : ''
    };
    let profileTitle = "Le Pragmatiste Équilibré";
    let summaryTemplate = `Pour toi {prenom}, c'est simple : un peu de goût, un peu de tendresse, et voilà. T'es du genre raisonnable. Mais bon, ça marche à tous les coups.`;

if (state.profile.Gout > 7.5 && state.profile.Tendrete < 5) {
    profileTitle = "Le Barbare au Palais Fin";
    summaryTemplate = `T'es un{e} warrior de la mâchoire, {prenom}. La **Tendreté** ? C'est pour les fragiles. Toi tu veux du **Goût**, du vrai, quitte à y passer la soirée à mastiquer. T'as pas peur de te battre pour ton plaisir.`;
} else if (state.profile.Tendrete > 8 && state.profile.Jutosite > 7) {
    profileTitle = "L'Adepte de la Douceur";
    summaryTemplate = `Ta philosophie {prenom} ? Zéro effort, max de bonheur. Pour toi, une viande doit fondre toute seule dans ta bouche. **Tendreté** et **Jutosité** au max, sinon c'est même pas la peine. T'as autre chose à faire que mâcher pendant trois plombes.`;
} else if (state.profile.Gout > 8 && state.profile.Persillage > 7) {
    profileTitle = "L'Hédoniste du Gras";
    summaryTemplate = `T'as tout compris à la vie, {prenom} : le gras, c'est le bonheur. Tu veux du **Goût** qui en met plein les papilles et du **Persillage** qui fait des miracles à la cuisson. Les morceaux maigres ? Tu laisses ça à ceux qui font semblant d'aimer leur vie.`;
} else if (state.profile.Tendrete > 7 && state.profile.Gout > 7) {
    profileTitle = "L'Épicurien{ne} Exigeant{e}";
    summaryTemplate = `Le beurre ET l'argent du beurre, voilà ce que tu veux {prenom}. Une viande qui soit **Tendre** comme un nuage ET qui explose en **Saveurs** comme un feu d'artifice. Bref, tu veux tout. Et alors ? T'as bien raison.`;
}

    const stats = { Tendrete: state.profile.Tendrete, Gout: state.profile.Gout, Jutosite: state.profile.Jutosite, Persillage: state.profile.Persillage };
    const sortedStats = Object.entries(stats).sort((a, b) => b[1] - a[1]);
    const [highestStatName, highestStatValue] = sortedStats[0];
    const EXTREME_THRESHOLD = 8.0;
    if (highestStatValue >= EXTREME_THRESHOLD && !summaryTemplate.toLowerCase().includes(highestStatName.toLowerCase())) { const extremeStatSentences = { Gout: " On note tout de même une recherche quasi obsessionnelle du **Goût** brut.", Tendrete: " Mais votre signature secrète, c'est cette exigence absolue de **Tendreté**.", Jutosite: " Cependant, votre véritable point faible reste une quête gourmande de **Jutosité**.", Persillage: " Mais ne nous mentons pas : au final, ce qui vous trahit, c'est cet amour immodéré pour un **Persillage** généreux." }; summaryTemplate += extremeStatSentences[highestStatName]; }
    const finalSummary = formatText(summaryTemplate, formatData);
    const finalTitle = formatText(profileTitle, formatData);

    let bestMatch = triggeringMatchProduct;
    if (!bestMatch) {
        const allScores = ALL_PRODUCTS.map(p => ({ p, score: calculateScore(p, state.profile) })).sort((a,b) => b.score - a.score);
        bestMatch = allScores[0]?.p;
    }
    
    // ✅ On prépare les URLs pour le visuel
    const logoUrl = "https://raw.githubusercontent.com/metscarnes/bimi-metscarnes/main/Logo%20Mets%20Carn%C3%A9s%20HD.png";
    const meatImageUrl = bestMatch ? bestMatch.image_url : "https://via.placeholder.com/150/1a1614/d4b896?text=🥩";

  const ctaHtml = bestMatch ? 
    `<a href="#" class="btn-cta-profile" data-produit="${encodeURIComponent(bestMatch.Produit)}">Découvrez ${formatProduitAvecArticle(bestMatch.Produit)}</a>` :
    ``;

  DOM.appScreens.profile.innerHTML = `
    <div class="profile-container">
            
            <!-- ✅ DÉBUT DU BLOC AJOUTÉ -->
            <div class="profile-match-visual profile-reveal-item" style="--delay: 0.2s;">
                <div class="profile-match-logo" style="background-image: url('${logoUrl}')"></div>
                <div class="profile-match-meat" style="background-image: url('${meatImageUrl}')"></div>
            </div>
            <!-- ✅ FIN DU BLOC AJOUTÉ -->

            <h1 class="profile-reveal-item" style="--delay: 0.4s;">Ton Profil Carnivore</h1>
            
            <h2 class="profile-reveal-item" style="color: var(--accent); font-style: italic; margin-bottom: 2rem; --delay: 0.5s;">"${finalTitle}"</h2>
            
            <p class="profile-reveal-item" style="font-size: 1.2rem; line-height: 1.8; margin-bottom: 3rem; --delay: 0.6s;">${finalSummary.replace(/\*\*(.*?)\*\*/g, '<strong style="color: var(--primary);">$1</strong>')}</p>
            
            <div style="width: 280px; height: 280px; margin: 0 auto 1.5rem;">
                <svg id="profile-radar-final" viewBox="0 0 100 100"></svg>
            </div>
            
            <div class="profile-actions-group profile-reveal-item" style="--delay: 0.8s;">
                <div class="profile-recommendation">
                    <h1 class="recommendation-label">On est sympa,<br>on organise votre premier date :</h1>
                </div>
                ${ctaHtml}
                <button class="btn" id="continue-swiping-btn">Continuer à Swiper</button>
            </div>
        </div>`;
        
    drawRadar(state.profile, 'profile-radar-final');
    
  DOM.appScreens.profile.querySelector('#continue-swiping-btn').addEventListener('click', () => {
        showAppScreen('swipe');
        renderSwipe();
    });
  // CTA produit : ouvrir modal plutôt que nouvelle page
  const cta = DOM.appScreens.profile.querySelector('.btn-cta-profile');
  if (cta) {
    cta.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      try { showModal(bestMatch); } catch (err) { window.location.href = bestMatch.product_url || '#'; }
    });
  }
    
    showAppScreen('profile');
}
/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : renderProfileScreen ========= */
/* ========================================================== */

    function parseBioTemplate(template, user) {
        if (!template || !user) return "";
        const userGenre = (user.genre || "").toLowerCase();
        const inverseGenre = userGenre.includes("monsieur") ? "feminin" : "masculin";
        return template.replace(/\{\{(.*?)\}\}/g, (_, content) => {
            const parts = content.split("|").reduce((acc, part) => { const [key, val] = part.split(":").map(s => s.trim()); acc[key] = val; return acc; }, {});
            if (inverseGenre === "feminin") return (parts.adj_f || parts.part_f || parts.nom_f || parts.pro_f || parts.comp_f || parts.alt_f || Object.values(parts)[0] || "");
            else return (parts.adj_m || parts.part_m || parts.nom_m || parts.pro_m || parts.comp_m || parts.alt_m || Object.values(parts)[0] || "");
        });
    }

    function getArticleEtAdjectif(nom, genre = 'masculin', adjectif = '') {
        if (!nom) return { articleDef: '', articleIndef: '', adjFinal: ''};
        const nomTrimmed = nom.trim();
        const startsWithVowel = /^[aeiouhàâéèêëïü]/i.test(nomTrimmed);
        const isFeminin = genre.toLowerCase().startsWith('f');
        const articleDef = startsWithVowel ? "l’" : (isFeminin ? "la " : "le ");
        const articleIndef = isFeminin ? "une " : "un ";
        let adjFinal = adjectif;
        if (startsWithVowel) {
            if (adjectif === 'beau') adjFinal = 'bel';
            if (adjectif === 'vieux') adjFinal = 'vieil';
            if (adjectif === 'nouveau') adjFinal = 'nouvel';
        } else {
            if (isFeminin) {
                if (adjectif === 'beau') adjFinal = 'belle';
                if (adjectif === 'vieux') adjFinal = 'vieille';
                if (adjectif === 'nouveau') adjFinal = 'nouvelle';
            }
        }
        return { articleDef, articleIndef, adjFinal };
    }

/* ========================================================== */
/* ========= DÉBUT DU BLOC REMPLACÉ : function createCard ========= */
/* ========================================================== */

function createCard(m, deckElement) {
    const d = deckElement;
    if (!d) {
        console.error("Erreur : L'élément 'deck' n'a pas été fourni à createCard.");
        return null;
    }

    const c = document.createElement('div');
  c.className = 'card';
  c.dataset.produit = m.Produit;
  c.meatData = m;

  // ✅ Structure HTML mise à jour : media area (fixed height) + info block
  c.innerHTML = `
    <div class="card-choice like">Match</div>
    <div class="card-choice nope">Next</div>
    <div class="card-media" style="background-image: url('${m.image_url || "https://via.placeholder.com/450x600/1a1614/d4b896?text=🥩"}')">
      <div class="card-sensor-bars">${createThermoBars(m)}</div>
      <div class="card-gradient-overlay"></div>
    </div>
    <div class="card-info">
      <div class="card-info-content">
        <div class="card-text-wrapper">
          <div class="card-name">${m.Produit}</div>
          <div class="card-location"><span>🏠</span> Vit ici : ${state.user.city || 'Neuilly-Plaisance'}</div>
          ${m.bio_template ? `<p class="card-bio">${parseBioTemplate(m.bio_template, state.user)}</p>` : ''}
        </div>
        <svg class="card-expand-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="stroke: rgba(245,241,232,0.85);">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </div>
    <a href="#" class="card-external-link" data-produit="${encodeURIComponent(m.Produit)}">
    Ton rendez-vous est ici ↗
    </a>
    </div>
  `;
    
    const infoContent = c.querySelector('.card-info-content');
    const externalLink = c.querySelector('.card-external-link');

    if (infoContent) {
        infoContent.addEventListener('click', (e) => {
            e.stopPropagation(); 
            c.classList.toggle('is-expanded');
        });
    }

  if (externalLink) {
    externalLink.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      // Open product modal in-app instead of navigating away / opening new tab
      try { showModal(m); } catch (err) { window.location.href = m.product_url || '#'; }
    });
  }
    
    d.appendChild(c);
    
    return c;
}

/* ========================================================== */
/* ========= FIN DU BLOC REMPLACÉ : function createCard ========= */
/* ========================================================== */

    function createThermoBars(m) {
        const bars = [{ icon: '👅', label: 'Goût', value: m.Gout }, { icon: '🔪', label: 'Tendreté', value: m.Tendrete }, { icon: '💧', label: 'Jutosité', value: m.Jutosite }, { icon: '✨', label: 'Persillage', value: m.Persillage }];
        return bars.map((b, i) => {
            const v = Math.max(0, Math.min(10, b.value || 5));
            const percent = v * 10;
            const color = v >= 7 ? '#edc196' : v >= 4 ? '#d4a574' : '#b08968';
            return `<div class="thermo-line" style="--delay:${i * 0.25}s;"><div class="thermo-bar-row"><span class="thermo-icon">${b.icon}</span><div class="thermo-bar-container"><div class="thermo-bar-fill" style="--target-width:${percent}%; background:${color};"></div></div></div><span class="thermo-text">${b.label}</span></div>`;
        }).join('');
    }

function updateCardStates() { 
    const cards = DOM.appScreens.swipe.querySelectorAll('.card'); 
    cards.forEach((card, index) => { 
        card.classList.remove('is-active', 'is-next'); 
        if (index === 0) { 
            card.classList.add('is-active'); 
            initCardHammer(card); 
        } 
        else if (index === 1) { 
            card.classList.add('is-next'); 
        }
    }); 
}

function addNextCardToDeckIfNeeded() {
    const deckEl = DOM.appScreens.swipe.querySelector('#card-deck');
    if (!deckEl) return;
    const visualCards = deckEl.querySelectorAll('.card');
    const targetCardCount = Math.min(state.deck.length, 2);

    if (visualCards.length < targetCardCount) {
        const cardDataToAdd = state.deck[visualCards.length];
        if (cardDataToAdd) {
            createCard(cardDataToAdd, deckEl);
        }
    }
}
    
    function showModal(m) { const M = DOM.modals.product; const c = M.querySelector('.modal-content'); if (!c) return; const h = NUTRITIONAL_INFO_MAP.map(n => { const v = m[n.key]; if (v !== undefined && v !== null) return `<div class="nutrient-card"><div class="label">${n.label}</div><div class="value">${String(v).replace('.',',')} ${n.unit}</div></div>`; return ''; }).join(''); c.innerHTML = `<div class="profile-header"><img src="${m.image_url||'https://via.placeholder.com/100/1a1614/d4b896?text=🥩'}" alt="${m.Produit}" class="profile-image"><div class="profile-info" style="display:flex;justify-content:space-between;align-items:flex-start;flex-grow:1;"><h1 class="product-title" style="margin-bottom:0;">${m.Produit}</h1><div class="nutri-score-badge"><div class="label">Nutri-Score</div><div class="score score-${m.NutriScore||'C'}">${m.NutriScore||'N/A'}</div></div></div></div><div class="section-grid"><div class="description-section"><p><strong class="description-label">Description :</strong><span>${m.Description || 'N/A'}</span></p>${m.bio_template ? `<div style="margin-top:1.5rem;"><strong class="description-label">Bio comique :</strong><p style="margin-top:0.5rem;color:var(--text-light);font-style:italic;line-height:1.8;">${parseBioTemplate(m.bio_template, state.user)}</p></div>` : ''}<p style="margin-top:1.5rem;"><strong class="description-label">Conseil:</strong><span>${m.CuissonConseillee||'N/A'}</span></p></div><div class="radar-section" style="display:flex;align-items:center;justify-content:center;"><svg id="modal-radar" viewBox="0 0 100 100" style="max-width:250px;"></svg></div></div><div class="card-section"><h2 class="section-title">Valeurs Nutritionnelles</h2><div class="nutrient-grid">${h}</div></div><div class="actions" style="margin-top:2rem;border-top:1px solid var(--border-subtle);padding-top:2rem;"><button class="action-btn" id="modal-dislike-btn">❌</button><button class="action-btn" id="modal-like-btn">❤️</button></div><button id="modal-close-btn" class="btn" style="width:100%;margin-top:1rem;">Fermer</button>`; drawRadar(m, 'modal-radar'); M.classList.add('is-visible'); const t = DOM.appScreens.swipe.querySelector('.card.is-active'); if (!t || t.meatData.Produit !== m.Produit) return; const l = c.querySelector('#modal-like-btn'), d = c.querySelector('#modal-dislike-btn'), C = c.querySelector('#modal-close-btn'); const nL = l.cloneNode(true); l.parentNode.replaceChild(nL, l); const nD = d.cloneNode(true); d.parentNode.replaceChild(nD, d); nL.onclick = () => { M.classList.remove('is-visible'); animateSwipe(t, 1); }; nD.onclick = () => { M.classList.remove('is-visible'); animateSwipe(t, -1); }; C.onclick = () => M.classList.remove('is-visible'); M.onclick = e => { if (e.target === M) M.classList.remove('is-visible'); }; }
function drawRadar(data, svgId) {
    const svg = document.getElementById(svgId);
    if (!svg) return;
    
    const size = 100, center = size / 2;
    const values = [data.Gout || 5, data.Tendrete || 5, data.Persillage || 5, data.Jutosite || 5];
    
    const labels = [
        { class: 'legend-top', emoji: '👅', name: 'Goût' },
        { class: 'legend-right', emoji: '🔪', name: 'Tendreté' },
        { class: 'legend-bottom', emoji: '✨', name: 'Persillage' },
        { class: 'legend-left', emoji: '💧', name: 'Jutosité' }
    ];

    let points = '';
    let legendsHtml = '';

    values.forEach((v, i) => {
        const angle = -Math.PI / 2 + (i * Math.PI / 2);
        const scale = v / 10;
        const x = center + (center * 0.8 * scale * Math.cos(angle));
        const y = center + (center * 0.8 * scale * Math.sin(angle));
        points += `${x},${y} `;
    });
    
    labels.forEach(label => {
        legendsHtml += `<div class="radar-legend ${label.class}">
                          <span class="emoji">${label.emoji}</span>
                          ${label.name}
                        </div>`;
    });

    const parent = svg.parentNode;
    if (parent && parent.style.position !== 'relative') {
        parent.style.position = 'relative';
    }

    svg.innerHTML = `
        <polygon class="radar-bg" points="50,10 90,50 50,90 10,50" fill="none" stroke="rgba(237,193,150,0.15)" stroke-width="0.6"/>
        <polygon class="radar-shape" points="${points}" fill="rgba(237,193,150,0.5)" stroke="var(--accent)" stroke-width="1"/>
    `;
    
    parent.querySelectorAll('.radar-legend').forEach(el => el.remove());
    parent.insertAdjacentHTML('beforeend', legendsHtml);
}
/* ========================================================== */
/* ========= DÉBUT DU BLOC CORRIGÉ : generateConvergenceHint ========= */
/* ========================================================== */

function generateConvergenceHint() {
    const recentSwipes = state.swipeHistory.slice(-6);
    const minSwipes = 5;

    if (recentSwipes.length < minSwipes) {
        return {
            title: "Un peu de patience...",
            text: `Continuez à swiper ! Il me faut encore ${minSwipes - recentSwipes.length} choix pour analyser vos goûts. Chaque swipe est un indice !`,
            confirmText: "Compris !",
            isSignificant: false 
        };
    }

    const likedCards = recentSwipes.filter(s => s.decision === 1).map(s => s.meat);
    const dislikedCards = recentSwipes.filter(s => s.decision === -1).map(s => s.meat);

    const traits = [
        { key: 'Tendrete', name: 'Tendreté', gender: 'f', high: 'très tendres', low: 'plutôt fermes', adj: 'tendre' },
        { key: 'Gout', name: 'Goût', gender: 'm', high: 'très savoureux', low: 'plutôt doux', adj: 'savoureux' },
        { key: 'Persillage', name: 'Persillage', gender: 'm', high: 'généreusement persillés', low: 'plutôt maigres', adj: 'persillé' },
        { key: 'Jutosite', name: 'Jutosité', gender: 'f', high: 'bien juteux', low: 'plutôt secs', adj: 'juteux' }
    ];

    const findTopTraits = (cards, threshold, direction, count = 2) => {
        if (cards.length < 2) return [];
        const matchingTraits = traits.filter(trait => {
            return cards.every(card => direction === 'high' ? card[trait.key] >= threshold : card[trait.key] <= threshold);
        });
        return matchingTraits.slice(0, count);
    };

    const mustHaveTraits = findTopTraits(likedCards, 7.0, 'high');
    const dealBreakerTraits = findTopTraits(dislikedCards, 5.0, 'low');
    
    const prenom = state.user.nom ? state.user.nom.charAt(0).toUpperCase() + state.user.nom.slice(1) : "vous";
    const estMadame = state.user.genre === 'Madame';
    const accordE = estMadame ? 'e' : '';

    let title = "Ulysse à la rescousse !";
    let text = `${prenom}, vos goûts sont assez subtils. Pour m'aider, n'hésitez pas à faire des choix plus tranchés : un grand OUI ou un grand NON est plus parlant qu'une hésitation.`;
    let isSignificant = false; 

    if (mustHaveTraits.length >= 2) {
        title = "Le duo gagnant se précise !";
        const [trait1, trait2] = mustHaveTraits;
        text = `C'est clair, ${prenom} : vous êtes conquis${accordE} quand un morceau est à la fois **${trait1.adj}** et **${trait2.adj}**. C'est votre combinaison idéale !<br/><br/>Cherchez les profils qui excellent sur ces deux points, et la convergence va grimper en flèche.`;
        isSignificant = true; 
    }
    else if (mustHaveTraits.length === 1 && dealBreakerTraits.length === 1) {
        title = "Analyse stratégique...";
        const mustHave = mustHaveTraits[0];
        const dealBreaker = dealBreakerTraits[0];
        text = `Message reçu, ${prenom} ! Vous cherchez avant tout un morceau **${mustHave.adj}**, mais vous ne tolérez absolument pas un manque de **${dealBreaker.name}**.<br/><br/>Votre mission est donc double : maximiser l'un et éviter le pire sur l'autre. Un vrai défi d'équilibriste !`;
        isSignificant = true; 
    }
    else if (mustHaveTraits.length === 1) {
        title = "Votre critère n°1 est clair !";
        const mustHave = mustHaveTraits[0];
        text = `Aucun doute, ${prenom} : votre priorité absolue, c'est la **${mustHave.name}**. Vous validez systématiquement les morceaux qui sont **${mustHave.high}**.<br/><br/>C'est une excellente base ! Continuons sur cette lancée pour affiner les autres critères.`;
        isSignificant = true; 
    }
    else if (dealBreakerTraits.length === 1) {
        title = "Votre 'non' est très clair !";
        const dealBreaker = dealBreakerTraits[0];
        text = `Une chose est sûre, ${prenom} : vous fuyez les produits qui sont **${dealBreaker.low}**. Le manque de **${dealBreaker.name}** est un critère rédhibitoire pour vous.<br/><br/>C'est un super filtre ! Continuez à être aussi sélectif${accordE}, ça affine énormément votre profil.`;
        isSignificant = true; 
    }

    return { title, text: text.replace(/\*\*(.*?)\*\*/g, '<strong style="color: var(--primary);">$1</strong>'), confirmText: "Stratégie notée !", isSignificant }; 
} // ✅ L'accolade manquante est maintenant ici.

/* ========================================================== */
/* ========= FIN DU BLOC CORRIGÉ : generateConvergenceHint ========= */
/* ========================================================== */
/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : showCustomAlert ========= */
/* ========================================================== */

function showCustomAlert({ title, text, confirmText = 'Compris', cancelText = null }) { // ✅ Accepte un bouton d'annulation optionnel
    return new Promise(resolve => {
        const modalTitle = document.getElementById('alert-modal-title');
        const modalText = document.getElementById('alert-modal-text');
        const modalButtons = document.getElementById('alert-modal-buttons');
        const modalOverlay = DOM.modals.alert;

        modalTitle.textContent = title;
        modalText.innerHTML = text;

        let buttonsHtml = `<button class="modal-btn modal-btn-confirm">${confirmText}</button>`;
        if (cancelText) { // ✅ Si un texte d'annulation est fourni, on ajoute le deuxième bouton
            buttonsHtml += `<button class="modal-btn modal-btn-secondary">${cancelText}</button>`;
        }
        modalButtons.innerHTML = buttonsHtml;

        const confirmBtn = modalButtons.querySelector('.modal-btn-confirm');
        const cancelBtn = modalButtons.querySelector('.modal-btn-secondary');

        const closeAndResolve = (value) => {
            modalOverlay.classList.remove('is-visible');
            resolve(value); // ✅ Renvoie 'true' pour confirmation, 'false' pour annulation
        };

        confirmBtn.onclick = () => closeAndResolve(true);
        if (cancelBtn) {
            cancelBtn.onclick = () => closeAndResolve(false);
        }
        
        // Permet de fermer en cliquant à l'extérieur (équivaut à annuler)
        modalOverlay.onclick = (e) => {
            if (e.target === modalOverlay) {
                closeAndResolve(false);
            }
        };

        modalOverlay.classList.add('is-visible');
    });
}

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : showCustomAlert ========= */
/* ========================================================== */
    
/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : handleBackStep ========= */
/* ========================================================== */

async function handleBackStep() { // ✅ La fonction est maintenant asynchrone pour attendre la réponse du pop-up
    // Cas 1 : On est sur l'écran de swipe, de résultats ou de profil
    if (state.currentScreen === 'swipe' || state.currentScreen === 'results' || state.currentScreen === 'profile') {
        const confirmed = await showCustomAlert({ // ✅ On attend la confirmation
            title: "Retourner au questionnaire ?",
            text: "Cela réinitialisera votre progression de swipe pour affiner à nouveau votre profil.",
            confirmText: "Oui, retourner",
            cancelText: "Annuler"
        });

        if (confirmed) { // ✅ Si l'utilisateur confirme
            state.currentStep = QUESTION_STEPS.length - 1; // On se positionne sur la dernière question
            showAppScreen('questions');
            renderQuestionStep();
        }
        // Si l'utilisateur annule, on ne fait rien.

    // Cas 2 : On est dans le questionnaire, mais pas à la première question
    } else if (state.currentScreen === 'questions' && state.currentStep > 0) {
        state.currentStep--;
        renderQuestionStep();

    // Cas 3 (implicite) : On est à la première question. Le bouton retour ne fait plus rien.
    // On a supprimé l'ancien 'else' qui renvoyait à l'écran d'intro.
    }
}

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : handleBackStep ========= */
/* ========================================================== */
/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : renderResultsScreen ========= */
/* ========================================================== */

function renderResultsScreen() {
    const resultsContainer = DOM.appScreens.results;
    let content = '';

    if (state.convergenceMatches.length > 0) {
        const userLogoUrl = "https://raw.githubusercontent.com/metscarnes/bimi-metscarnes/main/Logo%20Mets%20Carn%C3%A9s%20HD.png";
        const sortedMatches = [...state.convergenceMatches].sort((a, b) => b.score - a.score);
    const listItems = sortedMatches.map((match, index) => {
            const product = match.product;
            const compatibility = Math.min(99, Math.round(match.score));
            return `
                <li class="match-gallery-item" style="--delay: ${index * 0.1}s;">
                    <div class="match-gallery-pfps">
                        <div class="user-pfp" style="background-image: url('${userLogoUrl}')"></div>
                        <div class="product-pfp" style="background-image: url('${product.image_url || "https://via.placeholder.com/150/1a1614/d4b896?text=🥩"}')"></div>
                    </div>
                    <div class="match-gallery-info">
                        <h3>${product.Produit}</h3>
                        <p class="match-compatibility">🏆 Profil idéal validé à ${compatibility}%</p>
            <a href="#" class="btn-view-product" data-index="${index}">Ton date t'attend ! ➔</a>
                    </div>
                </li>
            `;
        }).join('');

        content = `
            <h1>Vos Profils Idéaux</h1>
            <p class="results-subtitle">Voici les matchs validés par l'algorithme de convergence.</p>
            <ul id="matches-list">${listItems}</ul>
        `;
    } else {
        content = `
            <h1>Vos Profils Idéaux</h1>
            <p class="results-subtitle">L'algorithme n'a pas encore validé de profil idéal pour vous.</p>
            <div class="no-matches-message">
                <p>Continuez à swiper pour atteindre votre première convergence !</p>
            </div>
        `;
    }

    resultsContainer.innerHTML = `
        <button id="view-profile-from-results-btn">Voir mon dernier profil</button> 
        ${content}
        <div class="results-actions">
            <button class="btn" id="continue-swiping-from-results">Continuer à Swiper</button>
        </div>
    `;

  // ✅ LOGIQUE DU NOUVEAU BOUTON AJOUTÉE ICI
    resultsContainer.querySelector('#view-profile-from-results-btn').addEventListener('click', () => {
        renderProfileScreen(); // Appelle l'écran de profil
    });

    resultsContainer.querySelector('#continue-swiping-from-results').addEventListener('click', () => {
        showAppScreen('swipe');
        renderSwipe(); // On s'assure de bien re-render l'écran de swipe
    });

  // Attach product modal handlers for result items (SPA behaviour)
  const resultButtons = resultsContainer.querySelectorAll('.btn-view-product');
  resultButtons.forEach(btn => {
    const idx = parseInt(btn.dataset.index, 10);
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const match = sortedMatches[idx];
      if (match && match.product) {
        try { showModal(match.product); } catch (err) { window.location.href = match.product.product_url || '#'; }
      }
    });
  });

    showAppScreen('results');
}

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : renderResultsScreen ========= */
/* ========================================================== */function bindGlobalEvents() {
    DOM.buttons.start.addEventListener('click', transitionToApp);

    const backBtn = document.getElementById('back-btn');
    if (backBtn) {
        backBtn.addEventListener('click', handleBackStep);
    }
    
    DOM.buttons.reset.addEventListener('click', () => {
        if (confirm("Voulez-vous vraiment tout réinitialiser ? Votre profil et votre historique seront effacés.")) {
            localStorage.removeItem('carnematch_session');
            localStorage.removeItem('mets_journal');
            location.reload();
        }
    });
    
    document.addEventListener("keydown", (e) => {
        const modalOpen = document.querySelector('.modal-overlay.is-visible');
        const swipeScreen = document.querySelector('#swipe-screen');
        if (modalOpen || !swipeScreen || !swipeScreen.classList.contains('active')) return;

        const activeCard = document.querySelector('.card.is-active');
        if (!activeCard) return;

        let direction = null;
        if (e.key === "ArrowRight") direction = 1;
        else if (e.key === "ArrowLeft") direction = -1;

        if (direction !== null) {
            e.preventDefault();
            const choiceEl = activeCard.querySelector(direction === 1 ? '.like' : '.nope');
            if (choiceEl) {
                choiceEl.style.transition = "opacity 0.15s ease";
                choiceEl.style.opacity = 1;
                setTimeout(() => {
                    choiceEl.style.opacity = 0;
                    animateSwipe(activeCard, direction);
                }, 150);
            } else {
                animateSwipe(activeCard, direction);
            }
        }
    });
}
async function bindIntroEvents() {
        const introContainer = DOM.appScreens.intro;
        const dialogueEl = introContainer.querySelector('#dialogue');
        const step1 = introContainer.querySelector('#intro-step-1');
        const step2 = introContainer.querySelector('#intro-step-2');
        const nameInput = introContainer.querySelector('#name-input');
        const greetingEl = introContainer.querySelector('#intro-greeting');

        introContainer.querySelectorAll('.btn-genre').forEach(b => {
            b.addEventListener('click', e => {
                introContainer.querySelectorAll('.btn-genre').forEach(x => x.classList.remove('selected'));
                e.currentTarget.classList.add('selected');
                state.user.genre = e.currentTarget.dataset.genre;
            });
        });

        introContainer.querySelector('#btn-next-step').addEventListener('click', async () => {
            const nom = nameInput.value.trim();
            const hasNumbers = /\d/.test(nom);

            if (hasNumbers) {
                state.consecutiveNameErrors++;
                if (state.consecutiveNameErrors >= 2) {
                    await showCustomAlert({
                        title: "Insistance Détectée...",
                        text: "Ok, ok, j'ai compris ! Bienvenue, R2-D2. On va dire que vous êtes un Monsieur.",
                        confirmText: "Bip Boup !"
                    });
                    state.user.nom = "R2-D2 🤖";
                    state.user.genre = "Monsieur";
                    state.consecutiveNameErrors = 0;
                } else {
                    return showCustomAlert({
                        title: "R2-D2, c'est toi ? 🤖",
                        text: "Un prénom ne contient pas de chiffres ! (Seules les lettres sont autorisées)"
                    });
                }
            } else {
                if (!nom) return showCustomAlert({ title: "Comment vous appelez-vous ?", text: "Veuillez entrer votre prénom." });
                if (!state.user.genre) return showCustomAlert({ title: "Petite précision...", text: "Veuillez choisir 'Monsieur' ou 'Madame'." });
                
                state.consecutiveNameErrors = 0;
                state.user.nom = nom;
if (state.user.nom === "ulyssecampiglia") { // ✅ C'est ici que la magie opère !
                    activateDebugTools();
                }
            }

            state.user.styleNarratif = detectNarrativeStyle(state.user);
            await requestLocation(); 
            saveSession();

            const adjective = state.user.genre === 'Madame' ? 'Prête' : 'Prêt';
            greetingEl.textContent = `Enchanté, ${capitalize(state.user.nom)} ! ${adjective} à trouver la perle rare ?`;
            
            step1.classList.remove('is-active');
            dialogueEl.style.opacity = '0';
            setTimeout(() => {
                step2.classList.add('is-active');
            }, 500);
        });

        introContainer.querySelector('#btn-full-start').addEventListener('click', () => {
            nextQuestion();
        });

introContainer.querySelector('#btn-fast-start').addEventListener('click', () => {
            // ✅ On saute directement à la dernière question (les interdits)
            state.currentStep = QUESTION_STEPS.length - 1; 
            showAppScreen('questions'); // ✅ On affiche l'écran des questions
            renderQuestionStep(); // ✅ On affiche la question des interdits
            // La logique existante dans renderQuestionStep/nextQuestion s'occupera de lancer le chargement après cette étape.
        });
    }
   

 function bindQuestionEvents() { const q = DOM.appScreens.questions, s = QUESTION_STEPS[state.currentStep]; if (s.type === 'multi') { const n = q.querySelector('#q-next'), a = q.querySelectorAll('.answer-card'); n.disabled = true; n.style.opacity = '0.5'; n.style.cursor = 'not-allowed'; n.addEventListener('click', () => { if (!n.disabled) nextQuestion(); }); a.forEach(c => { c.addEventListener('click', () => { const v = c.dataset.value; if (state.profile.interdits === null) state.profile.interdits = []; if (v === "Aucune restriction") { state.profile.interdits = []; a.forEach(x => x.classList.remove('selected')); c.classList.add('selected'); setTimeout(() => nextQuestion(), 200); return; } q.querySelector('[data-value="Aucune restriction"]')?.classList.remove('selected'); c.classList.toggle('selected'); if (c.classList.contains('selected')) { if (!state.profile.interdits.includes(v)) state.profile.interdits.push(v); } else { state.profile.interdits = state.profile.interdits.filter(x => x !== v); } const h = q.querySelectorAll('.answer-card.selected').length > 0; n.disabled = !h; n.style.opacity = h ? '1' : '0.5'; n.style.cursor = h ? 'pointer' : 'not-allowed'; }); }); } else { q.querySelectorAll('.answer-card').forEach(c => c.addEventListener('click', e => handleChoiceSelection(e.currentTarget, parseInt(e.currentTarget.dataset.index)))); } }
   

/* ========================================================== */
/* ========= DÉBUT DU BLOC À REMPLACER : bindSwipeEvents ========= */
/* ========================================================== */

function bindSwipeEvents() {
    const s = DOM.appScreens.swipe;
    const l = s.querySelector('#like-btn');
    const d = s.querySelector('#dislike-btn');
    const u = s.querySelector('#undo-btn');
    const v = document.getElementById('view-matches-btn'); // ✅ On récupère notre bouton

    // On utilise la technique "cloneNode" pour garantir que les écouteurs d'événements sont propres
    const nL = l.cloneNode(true); l.parentNode.replaceChild(nL, l);
    const nD = d.cloneNode(true); d.parentNode.replaceChild(nD, d);
    const nU = u.cloneNode(true); u.parentNode.replaceChild(nU, u);
    
    // ✅ On applique la même technique robuste à notre bouton
    const nV = v.cloneNode(true); v.parentNode.replaceChild(nV, v);

    // On attache les événements aux nouveaux boutons "clonés"
    nL.addEventListener('click', () => { const t = s.querySelector('.card.is-active'); if (t) animateSwipe(t, 1); });
    nD.addEventListener('click', () => { const t = s.querySelector('.card.is-active'); if (t) animateSwipe(t, -1); });
    nU.addEventListener('click', handleUndoSwipe);
    nV.addEventListener('click', renderResultsScreen); // ✅ L'événement est maintenant correctement attaché ici
}

/* ========================================================== */
/* ========= FIN DU BLOC À REMPLACER : bindSwipeEvents ========= */
/* ========================================================== */
    
    
    function handleChoiceSelection(e, i) { 
const s = QUESTION_STEPS[state.currentStep], 
o = s.options[i]; 
 state.userAnswers[s.id] = i;
if (o.set) Object.assign(state.profile, o.set);
if (o.apply) o.apply(); 
saveSession();

DOM.appScreens.questions.querySelectorAll('.answer-card').forEach(c => c.classList.remove('selected')); e.classList.add('selected'); DOM.appScreens.questions.querySelectorAll('.answer-card').forEach(c => c.style.pointerEvents = 'none'); nextQuestion();saveSession(); }
    function nextQuestion() { const c = state.currentScreen === 'intro' ? DOM.appScreens.intro : DOM.appScreens.questions; c.classList.add('is-exiting'); setTimeout(() => { if (state.currentScreen === 'intro') { showAppScreen('questions'); renderQuestionStep(); } else { state.currentStep++; renderQuestionStep(); } c.classList.remove('is-exiting'); }, 400); }
    
function handleUndoSwipe() {
    if (!state.lastSwipedCard) {
        showFeedbackMessage("Rien à annuler.");
        return;
    }

    const { meat, decision } = state.lastSwipedCard;

    state.swipedProductNames.delete(meat.Produit); 
    if (decision === 1) {
        state.matches = state.matches.filter(m => m.Produit !== meat.Produit); 
    }
    
    if (state.profileHistory.length > 1) { 
        state.profileHistory.pop();
        const previousProfile = state.profileHistory[state.profileHistory.length - 1];
        Object.assign(state.profile, previousProfile); 
    }

    state.deck.unshift(meat); 
    state.lastSwipedCard = null; 

    const deckEl = DOM.appScreens.swipe.querySelector('#card-deck');
    if (deckEl) {
        deckEl.innerHTML = ''; 
        addNextCardToDeckIfNeeded(); 
        addNextCardToDeckIfNeeded(); 
        updateCardStates(); 
    }
    
    updateConvergenceGauge();
    showFeedbackMessage(`"${meat.Produit}" est de retour !`);
    saveSession();
}
    function initCardHammer(c) {
        if (c.hammerInitialized) return;
        c.hammerInitialized = true;
    // touchAction 'none' empêche le navigateur d'interpréter les gestes
    // (évite que le scroll vertical bloque / fasse 'sauter' la carte)
    const h = new Hammer(c, {
      touchAction: 'none'
    });
    // threshold réduit les faux positifs (petits mouvements)
    h.get('pan').set({ direction: Hammer.DIRECTION_HORIZONTAL, threshold: 10 }); // ✅ Force le pan horizontal uniquement

    h.on('panstart', e => {
      c.isPanning = true;
      c.dataset.panning = '1';
      // Prevent native touch scrolling while interacting with the card
      // We attach a non-passive touchmove listener so we can call preventDefault
      const prevent = function(ev) { ev.preventDefault(); };
      c._preventTouchMove = prevent;
      document.addEventListener('touchmove', prevent, { passive: false });
    });
    h.on('pan', e => handlePan(e, c));
    h.on('panend', e => {
      c.isPanning = false;
      delete c.dataset.panning;
      // remove the temporary touchmove blocker
      if (c._preventTouchMove) {
        try { document.removeEventListener('touchmove', c._preventTouchMove, { passive: false }); } catch (err) { document.removeEventListener('touchmove', c._preventTouchMove); }
        delete c._preventTouchMove;
      }
      handlePanEnd(e, c);
    });
    }
  function handlePan(e, c) {
    // Defensive guards: if an animation is playing or this card is already
    // processed, ignore pan updates to avoid race conditions.
    if (state.isAnimating || c.dataset.processed) return;

    // ✅ FIX CRITIQUE : On supprime complètement deltaY pour éviter le saut sur mobile
    c.style.transition = 'none';
    c.style.transform = `translateX(${e.deltaX}px) rotate(${e.deltaX / 20}deg)`;
    const o = Math.min(Math.abs(e.deltaX) / 100, 1);
    const likeEl = c.querySelector('.like');
    const nopeEl = c.querySelector('.nope');
    if (likeEl) likeEl.style.opacity = e.deltaX > 0 ? o : 0;
    if (nopeEl) nopeEl.style.opacity = e.deltaX > 0 ? 0 : o;
  }

  function handlePanEnd(e, c) {
    // On remet une transition pour l'animation de retour ou d'éjection
    c.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
    const likeEl = c.querySelector('.like');
    const nopeEl = c.querySelector('.nope');
    if (likeEl) likeEl.style.opacity = 0;
    if (nopeEl) nopeEl.style.opacity = 0;

    // If an animation is running or the card has already been processed,
    // bail out to avoid double actions (this was causing like+match races).
    if (state.isAnimating || c.dataset.processed) {
      // Ensure card returns to neutral visual state
      c.style.transform = 'translateX(0px) rotate(0deg) scale(1)';
      return;
    }

    // Only trigger swipe if displacement exceeds threshold
    if (Math.abs(e.deltaX) > 150) {
      // Ensure this card is the top of the deck (defensive)
      const topProduit = state.deck[0] ? state.deck[0].Produit : null;
      if (c.meatData && c.meatData.Produit && c.meatData.Produit !== topProduit) {
        // Not the active data card - ignore accidental gesture
        c.style.transform = 'translateX(0px) rotate(0deg) scale(1)';
        return;
      }

      animateSwipe(c, e.deltaX > 0 ? 1 : -1);
    } else {
      // Ne PAS vider style.transform (""), ça provoque un saut brutal
      // et peut laisser la carte collée à gauche. On remet une valeur
      // explicite qui correspond à l'état CSS .card.is-active (scale(1)).
      c.style.transform = 'translateX(0px) rotate(0deg) scale(1)';
    }
  }

function animateSwipe(card, direction) {
  // Prevent double-processing of the same card
  if (card.dataset.processed) return;

  if (state.isAnimating) { if (state.user.nom === "ulyssecampiglia") console.warn("⛔ Swipe ignoré (animation en cours)."); return; } // ✅ Correction
  state.isAnimating = true;
  card.dataset.processed = '1'; // mark as processed to avoid races
  card.style.pointerEvents = 'none';

    const meat = state.deck[0];
    if (!meat) { 
        state.isAnimating = false;
        return;
    }

    if (direction) {
        anime({
            targets: card,
            translateX: direction * 500,
            rotate: direction * 30,
            opacity: 0,
            duration: 400,
            easing: 'easeInQuad',
            complete: () => {
                card.remove();

                if (direction === 1) {
                    const score = calculateScore(meat, state.profile);
                    state.matches.push({ product: meat, score: score });
                }

                state.lastSwipedCard = { meat, decision: direction };
                state.swipedProductNames.add(meat.Produit);
                
                state.swipeHistory.push({ meat, decision: direction });
                if (state.swipeHistory.length > 10) state.swipeHistory.shift();
                
                state.deck.shift(); 
                
                adaptProfileOnMatch(meat, direction === 1);
                state.profileHistory.push(JSON.parse(JSON.stringify(state.profile)));
                if (state.profileHistory.length > 20) state.profileHistory.shift();
                
                const feedbackFinal = generateFeedbackForSwipe(meat, direction);
                showFeedbackMessage(feedbackFinal);
                
                updateConvergenceGauge(); 

/* ========================================================== */
/* ========= DÉBUT DU BLOC MODIFIÉ : Logique de Notification d'Astuce ========= */
/* ========================================================== */

                const minSwipesForHint = 4;
                if (state.swipeHistory.length >= minSwipesForHint) {
                    const currentHint = generateConvergenceHint();
                    
                    // On ne notifie l'utilisateur que si l'astuce est nouvelle ET pertinente
                    if (currentHint.text !== state.lastHintPresented && currentHint.isSignificant) { // ✅ On vérifie maintenant si l'astuce est pertinente
                        state.hasNewHint = true;
                        updateConvergenceGauge();
                    }
                }

/* ========================================================== */
/* ========= FIN DU BLOC MODIFIÉ : Logique de Notification d'Astuce ========= */
/* ========================================================== */

        if (direction === 1 && checkForConvergence()) {
          // Defer final match creation to the next animation frames to
          // avoid racing with other DOM/state updates from animateSwipe.
          const deckEl = document.querySelector('#card-deck');
          const savedMeat = meat;
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Re-check convergence in case state changed meanwhile
              if (!checkForConvergence()) {
                saveSession();
                return;
              }
              const finalCardElement = createCard(savedMeat, deckEl);
              if (finalCardElement) {
                finalCardElement.classList.add('is-active');
                triggerFinalMatchAnimation(finalCardElement);
              } else {
                renderProfileScreen();
              }
              saveSession();
            });
          });
          state.isAnimating = false;
          return;
        }
                
                addNextCardToDeckIfNeeded();
                updateCardStates();
                saveSession();
                
                state.isAnimating = false;
            }
        });
    } else {
        state.isAnimating = false;
    }
}
    function capitalize(s) {
        if (typeof s !== 'string' || !s) return '';
        return s.charAt(0).toUpperCase() + s.slice(1);
    }
function generateFeedbackForSwipe(meat, direction) {
    const action = direction === 1 ? 'like' : 'dislike';
    const prenom = (state.user.nom && state.user.nom.trim()) ? capitalize(state.user.nom) : null;
    const { articleDef } = getArticleEtAdjectif(meat.Produit, meat.Genre);
    const nomComplet = `${articleDef}${meat.Produit}`;

    const metsPhrase = generateNarrativeFeedback(state.user, state.profile, "swipe", action, meat.Categorie);

    const hook = action === 'like' ? 
        pickUnique([
            `Un bon choix avec ${nomComplet}.`,
            `Bien vu pour ${nomComplet}.`,
            `Validé ! ${nomComplet} rejoint vos favoris.`,
            `${nomComplet}... Intéressant.`
        ]) :
        pickUnique([
            `Pas de coup de foudre avec ${nomComplet}.`,
            `Visiblement, ${nomComplet} ne vous convainc pas.`,
            `${nomComplet} ne passe pas le test, on dirait.`
        ]);

    const finalPhrase = `${hook} ${metsPhrase.charAt(0).toLowerCase() + metsPhrase.slice(1)}`;
    
    if (!state.loggedProducts.has(formatProduitAvecArticle(meat.Produit))) {
        let journal = JSON.parse(localStorage.getItem("mets_journal") || "[]");
        const logEntry = {
            time: new Date().toLocaleTimeString(),
            produit: formatProduitAvecArticle(meat.Produit),
            prenom: prenom || "toi",
            type: action.toUpperCase(),
            phrase: finalPhrase,
            style: state.user.styleNarratif || "—",
            phase: "swipe"
        };
        journal.push(logEntry);
        localStorage.setItem("mets_journal", JSON.stringify(journal));
        if (typeof logMETS === "function") logMETS(logEntry);
        state.loggedProducts.add(logEntry.produit);
    }
    return finalPhrase;
}
function saveSession() {
    try {
        const sessionData = {
            user: state.user,
            profile: state.profile,
            currentStep: state.currentStep,
            currentScreen: state.currentScreen,
            deck: state.deck,
            matches: state.matches,
            convergenceMatches: state.convergenceMatches, // On sauvegarde aussi les vrais matchs
            swipedProductNames: Array.from(state.swipedProductNames),
            profileHistory: state.profileHistory
        };
        localStorage.setItem('carnematch_session', JSON.stringify(sessionData));
        console.log(`%c💾 SESSION SAUVEGARDÉE`, 'color: #2de9a1; font-weight: bold; background: #1a1614; padding: 2px 5px; border-radius: 3px;', `| Écran: ${state.currentScreen}`, `| Cartes restantes: ${state.deck.length}`, `| Prochaine carte: ${state.deck.length > 0 ? state.deck[0].Produit : 'Aucune'}`);
    } catch (e) {
        console.error("Sauvegarde de session échouée:", e);
    }
}
function restoreSwipeScreen() {
    showView('app');
    showAppScreen('swipe');
    DOM.appScreens.swipe.innerHTML = `
        <div class="convergence-gauge-container">
            <div class="convergence-gauge-label">
                Affinement du profil
                <span id="convergence-help-btn" class="help-icon" title="Comment ça marche ?">?</span>
                <span id="coach-popup">votre coach a des astuces pour vous ! ➔</span>
            </div>
            <div class="convergence-gauge-bar">
                <div class="convergence-gauge-fill" id="convergence-fill"></div>
            </div>
            <div class="convergence-gauge-percent" id="convergence-percent">0%</div>
        </div>
        <div id="feedback-toast" class="feedback-toast"></div>
        <div class="card-deck" id="card-deck"></div>
        <div class="actions"><button class="action-btn undo" id="undo-btn">↩️</button><button class="action-btn dislike" id="dislike-btn">❌</button><button class="action-btn like" id="like-btn">❤️</button></div>`;
    
    bindSwipeEvents();


    
    document.getElementById('convergence-help-btn').addEventListener('click', () => {
        const hint = generateConvergenceHint();
        showCustomAlert(hint);
        state.hasNewHint = false;
        state.lastHintPresented = hint.text;
        updateConvergenceGauge();
    });
    
    const cardDeckEl = DOM.appScreens.swipe.querySelector('#card-deck');
    if (!cardDeckEl) return; 

    if (state.deck && state.deck.length > 0) {
        createCard(state.deck[0], cardDeckEl);
        if (state.deck[1]) {
            createCard(state.deck[1], cardDeckEl);
        }
    }
    
    updateCardStates();
    updateConvergenceGauge();
}
async function loadAndRestoreSession() {
    try {
        const sessionJSON = localStorage.getItem('carnematch_session');
        if (!sessionJSON) {
            console.log('%c🔍 Aucune session sauvegardée trouvée.', 'color: #f9b930;');
            return false;
        }

        const sessionData = JSON.parse(sessionJSON);
        console.log(`%c🔄 SESSION TROUVÉE`, 'color: #f9b930; font-weight: bold; background: #1a1614; padding: 2px 5px; border-radius: 3px;', `| Utilisateur: ${sessionData.user.nom}`, `| Écran à restaurer: ${sessionData.currentScreen}`, `| Cartes à restaurer: ${sessionData.deck.length}`, `| Prochaine carte: ${sessionData.deck.length > 0 ? sessionData.deck[0].Produit : 'Aucune'}`);

       const userChoseToRestore = await new Promise(resolve => {
    // ✅ CORRECTION DÉFENSIVE
    let alertModal = document.getElementById('alert-modal');
    if (!alertModal) {
        console.warn("⚠️ Modal d’alerte introuvable — création forcée par sécurité.");
        alertModal = document.createElement('div');
        alertModal.id = "alert-modal";
        alertModal.className = "modal-overlay";
        alertModal.innerHTML = `
          <div class="modal-content" style="background:#1a1614;color:#F5F1E8;padding:1.5rem;border-radius:8px;max-width:400px;margin:auto;text-align:center;">
            <h2 id="alert-modal-title"></h2>
            <p id="alert-modal-text" style="margin-top:1rem;margin-bottom:1.5rem;"></p>
            <div id="alert-modal-buttons"></div>
          </div>`;
        document.body.appendChild(alertModal);
    }

    // 🧩 Bloc original de ton code
    document.getElementById('alert-modal-title').textContent = "Session trouvée";
    document.getElementById('alert-modal-text').innerHTML = `Reprendre où tu en étais, ${capitalize(sessionData.user.nom || 'invité')} ?`;
    document.getElementById('alert-modal-buttons').innerHTML = `
        <button class="modal-btn modal-btn-confirm" id="restore-yes">Reprendre</button>
        <button class="modal-btn modal-btn-secondary" id="restore-no">Recommencer</button>`;

            
            DOM.modals.alertTitle.textContent = "Session trouvée"; // ✅ On utilise les références de l'objet DOM.
            DOM.modals.alertText.innerHTML = `Reprendre où tu en étais, ${capitalize(sessionData.user.nom || 'invité')} ?`; // ✅
            DOM.modals.alertButtons.innerHTML = `<button class="modal-btn modal-btn-confirm" id="restore-yes">Reprendre</button><button class="modal-btn modal-btn-secondary" id="restore-no">Recommencer</button>`; // ✅
            
            DOM.modals.alert.querySelector('#restore-yes').onclick = () => { DOM.modals.alert.classList.remove('is-visible'); resolve(true); };
            DOM.modals.alert.querySelector('#restore-no').onclick = () => { DOM.modals.alert.classList.remove('is-visible'); resolve(false); };
            DOM.modals.alert.classList.add('is-visible');
        });

        if (userChoseToRestore) {
            console.log('%c✅ Restauration acceptée. Application de l\'état sauvegardé.', 'color: #2de9a1;');
            Object.assign(state.user, sessionData.user);
            Object.assign(state.profile, sessionData.profile);
            state.currentStep = sessionData.currentStep;
            state.currentScreen = sessionData.currentScreen;
            state.deck = sessionData.deck || [];
            state.matches = sessionData.matches || [];
            state.convergenceMatches = sessionData.convergenceMatches || []; // On restaure les vrais matchs
            state.swipedProductNames = new Set(sessionData.swipedProductNames || []);
            state.profileHistory = sessionData.profileHistory || [];
            
            const screenToRestore = state.currentScreen;
            showView('app');

            if (screenToRestore === 'swipe') {
                restoreSwipeScreen();
            } else if (screenToRestore === 'questions') {
                showAppScreen('questions');
                renderQuestionStep();
            } else if (screenToRestore === 'results') {
                renderResultsScreen(); // On utilise renderResultsScreen qui est déjà défini
            } else if (screenToRestore === 'profile') {
                renderProfileScreen(); // On utilise renderProfileScreen qui est déjà défini
            } else {
                showAppScreen('intro');
                renderIntro();
            }
            return true;
        } else {
            console.log('%c❌ Restauration refusée. Suppression de la session.', 'color: #fe5269;');
            localStorage.removeItem('carnematch_session');
            localStorage.removeItem('mets_journal');
            return false;
        }
    } catch (e) {
        console.error("Erreur lors de la restauration de session:", e);
        localStorage.removeItem('carnematch_session');
        localStorage.removeItem('mets_journal');
        return false;
    }
}    
function activateDebugTools() {
    console.log('%c🕵️‍♂️ Mode Développeur Activé pour "ulyssecampiglia"', 'color: #8E44AD; font-weight: bold; font-size: 14px;');

    // --- Création du bouton "TEST MATCH" ---
    if (!document.getElementById('debug-match-btn')) { // ✅ On vérifie qu'il n'existe pas déjà
        const debugBtn = document.createElement('button');
        debugBtn.id = 'debug-match-btn';
        debugBtn.textContent = '⚡ TEST MATCH';
        Object.assign(debugBtn.style, {
            position: 'fixed',
            bottom: '10px',
            left: '10px',
            zIndex: '10000',
            padding: '10px 15px',
            background: '#8E44AD',
            color: 'white',
            border: '2px solid white',
            borderRadius: '8px',
            cursor: 'pointer',
            fontFamily: "'Loyola Pro Bold', serif",
            boxShadow: '0 5px 20px rgba(0,0,0,0.5)'
        });
        debugBtn.addEventListener('click', () => {
                            const fakeCard = { meatData: ALL_PRODUCTS[Math.floor(Math.random() * ALL_PRODUCTS.length)] };
                console.log("⚡ Déclenchement manuel de l'animation de Match avec :", fakeCard.meatData.Produit);
                triggerFinalMatchAnimation(fakeCard);
            
        });
        document.body.appendChild(debugBtn);
    }

    // --- Activation du panneau de débogage M.E.T.S ---
    const panel = document.getElementById("mets-debug-panel");
    if(panel) panel.style.display = "block"; // ✅ On rend le panneau visible

    // On attache l'écouteur du clavier UNIQUEMENT en mode debug
    document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "m" && panel) { // ✅ Le raccourci 'M' est maintenant conditionnel
          panel.style.display = panel.style.display === "none" ? "block" : "none";
        }
    });
}
    async function init() {
        bindGlobalEvents();

        const sessionRestored = await loadAndRestoreSession();
        if (!sessionRestored) {
            showView('welcome');
        }
        window.addEventListener('beforeunload', saveSession);
        
        setInterval(() => {
            if (state.currentScreen === 'swipe' && DOM.appScreens.swipe && DOM.appScreens.swipe.classList.contains('active')) {
                const svg = document.getElementById('profile-radar-svg');
                if (!svg) return;
                const jitter = { ...state.profile };
                const keys = ['Tendrete', 'Gout', 'Jutosite', 'Persillage'];
                const key = keys[Math.floor(Math.random() * keys.length)];
                jitter[key] = Math.max(0, Math.min(10, jitter[key] + (Math.random() - 0.5) * 0.2));
                drawRadar(jitter, 'profile-radar-svg');
            }
        }, 3000);
    }

  init();

  })(); // Close the main IIFE

}); // Close the DOMContentLoaded event listener

// ============================================================
// CONSOLE VISUELLE M.E.T.S ET GESTION CLAVIER
// ============================================================
(function () {
  const panel = document.createElement("div");
  panel.id = "mets-debug-panel";
  Object.assign(panel.style, {
    position: 'fixed', bottom: '10px', right: '10px', width: '340px', maxHeight: '320px',
    overflowY: 'auto', fontFamily: 'monospace', fontSize: '12px', background: 'rgba(0,0,0,0.8)',
    color: '#F5F1E8', border: '1px solid #cc8956', borderRadius: '6px',
    padding: '8px 10px 10px 10px', boxShadow: '0 0 10px rgba(0,0,0,0.4)',
    display: 'none', zIndex: '9999'
  });
  document.body.appendChild(panel);

  const header = document.createElement("div");
  header.textContent = "🧭 M.E.T.S Debug (M pour masquer)";
  Object.assign(header.style, { fontWeight: 'bold', color: '#cc8956', marginBottom: '6px', position: 'relative' });
  panel.appendChild(header);

  const copyBtn = document.createElement("button");
  copyBtn.textContent = "📋 Copier";
  Object.assign(copyBtn.style, { position: 'absolute', top: '0', right: '85px', background: '#8B7355', color: 'white', border: 'none', padding: '3px 8px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px' });
  
  const clearBtn = document.createElement("button");
  clearBtn.textContent = "🗑️ Clear";
  Object.assign(clearBtn.style, { position: 'absolute', top: '0', right: '10px', background: '#50241c', color: 'white', border: 'none', padding: '3px 8px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px' });

  header.appendChild(copyBtn);
  header.appendChild(clearBtn);

  const logContainer = document.createElement("div");
  panel.appendChild(logContainer);

  copyBtn.onclick = () => {
    const journal = JSON.parse(localStorage.getItem("mets_journal") || "[]");
    if (journal.length === 0) {
      copyBtn.textContent = "❌ Vide";
      setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
      return;
    }
    const text = [...journal].reverse().map(e => `[${e.time}] ${e.type} ${e.produit}\n${e.phrase}\n${e.style} • ${e.phase}`).join("\n\n");
    navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = "✅ Copié !";
        setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
    }).catch(() => {
        copyBtn.textContent = "⚠️ Erreur";
        setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
    });
  };

  clearBtn.onclick = () => {
    if (!confirm("⚠️ Vider complètement le journal M.E.T.S ?")) return;
    localStorage.removeItem("mets_journal");
    logContainer.innerHTML = "<i>(Journal effacé)</i>";
    clearBtn.textContent = "✅ Effacé";
    setTimeout(() => (clearBtn.textContent = "🗑️ Clear"), 1500);
  };

  window.logMETS = function (entry) {
    if (!panel || !logContainer) return;
    const line = document.createElement("div");
    line.innerHTML = `<div style="margin-bottom:4px;border-bottom:1px dashed #444;padding-bottom:2px;"><span style="color:#888;">[${entry.time}]</span> <span style="color:#cc8956;">${entry.type}</span> <span style="color:#F5F1E8;">${entry.produit}</span><br><span style="color:#F5F1E8;">${entry.phrase}</span><br><span style="color:#777;">${entry.style} • ${entry.phase}</span></div>`;
    logContainer.prepend(line);
    // Trim the log to the most recent 50 entries
    while (logContainer.children.length > 50) {
      logContainer.removeChild(logContainer.lastChild);
    }
  };

})(); // Close the debug panel IIFE

</script>
</body>                const key = keys[Math.floor(Math.random() * keys.length)];
                jitter[key] = Math.max(0, Math.min(10, jitter[key] + (Math.random() - 0.5) * 0.2));
                drawRadar(jitter, 'profile-radar-svg');
            }
        }, 3000);
    }

  init();

  })(); // Close the main IIFE

}); // Close the DOMContentLoaded event listener

// ============================================================
// CONSOLE VISUELLE M.E.T.S ET GESTION CLAVIER
// ============================================================
(function () {
  const panel = document.createElement("div");
  panel.id = "mets-debug-panel";
  Object.assign(panel.style, {
    position: 'fixed', bottom: '10px', right: '10px', width: '340px', maxHeight: '320px',
    overflowY: 'auto', fontFamily: 'monospace', fontSize: '12px', background: 'rgba(0,0,0,0.8)',
    color: '#F5F1E8', border: '1px solid #cc8956', borderRadius: '6px',
    padding: '8px 10px 10px 10px', boxShadow: '0 0 10px rgba(0,0,0,0.4)',
    display: 'none', zIndex: '9999'
  });
  document.body.appendChild(panel);

  const header = document.createElement("div");
  header.textContent = "🧭 M.E.T.S Debug (M pour masquer)";
  Object.assign(header.style, { fontWeight: 'bold', color: '#cc8956', marginBottom: '6px', position: 'relative' });
  panel.appendChild(header);

  const copyBtn = document.createElement("button");
  copyBtn.textContent = "📋 Copier";
  Object.assign(copyBtn.style, { position: 'absolute', top: '0', right: '85px', background: '#8B7355', color: 'white', border: 'none', padding: '3px 8px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px' });
  
  const clearBtn = document.createElement("button");
  clearBtn.textContent = "🗑️ Clear";
  Object.assign(clearBtn.style, { position: 'absolute', top: '0', right: '10px', background: '#50241c', color: 'white', border: 'none', padding: '3px 8px', borderRadius: '4px', cursor: 'pointer', fontSize: '11px' });

  header.appendChild(copyBtn);
  header.appendChild(clearBtn);

  const logContainer = document.createElement("div");
  panel.appendChild(logContainer);

  copyBtn.onclick = () => {
    const journal = JSON.parse(localStorage.getItem("mets_journal") || "[]");
    if (journal.length === 0) {
      copyBtn.textContent = "❌ Vide";
      setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
      return;
    }
    const text = [...journal].reverse().map(e => `[${e.time}] ${e.type} ${e.produit}\n${e.phrase}\n${e.style} • ${e.phase}`).join("\n\n");
    navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = "✅ Copié !";
        setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
    }).catch(() => {
        copyBtn.textContent = "⚠️ Erreur";
        setTimeout(() => (copyBtn.textContent = "📋 Copier"), 1500);
    });
  };

  clearBtn.onclick = () => {
    if (!confirm("⚠️ Vider complètement le journal M.E.T.S ?")) return;
    localStorage.removeItem("mets_journal");
    logContainer.innerHTML = "<i>(Journal effacé)</i>";
    clearBtn.textContent = "✅ Effacé";
    setTimeout(() => (clearBtn.textContent = "🗑️ Clear"), 1500);
  };

  window.logMETS = function (entry) {
    if (!panel || !logContainer) return;
    const line = document.createElement("div");
    line.innerHTML = `<div style="margin-bottom:4px;border-bottom:1px dashed #444;padding-bottom:2px;"><span style="color:#888;">[${entry.time}]</span> <span style="color:#cc8956;">${entry.type}</span> <span style="color:#F5F1E8;">${entry.produit}</span><br><span style="color:#F5F1E8;">${entry.phrase}</span><br><span style="color:#777;">${entry.style} • ${entry.phase}</span></div>`;
    logContainer.prepend(line);
    // Trim the log to the most recent 50 entries
    while (logContainer.children.length > 50) {
      logContainer.removeChild(logContainer.lastChild);
    }
  };

})(); // Close the debug panel IIFE

</script>
</body>
